#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import { fileURLToPath } from 'url';

const DEFAULT_OUTPUT_DIR = 'public';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_FILENAME = 'readmesite-og-default.png';

const HTML_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{PAGE_TITLE}}</title>
    <meta property="og:type" content="website">
    <meta property="og:url" content="{{OG_URL}}">
    <meta property="og:title" content="{{PAGE_TITLE}}">
    <meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta property="og:image" content="{{OG_IMAGE_URL}}">
    <meta property="og:site_name" content="{{PAGE_TITLE}}">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="{{OG_URL}}">
    <meta name="twitter:title" content="{{PAGE_TITLE}}">
    <meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta name="twitter:image" content="{{OG_IMAGE_URL}}">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="{{FAVICON_URL}}" type="image/png">
</head>
<body>
    <main class="container">
        {{CONTENT}}
    </main>
    <footer>
        <p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a></p>
    </footer>
</body>
</html>`;

const CSS_STYLES = `
body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;}
.container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);}
h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;}
h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;}
p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;}
a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;}
code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;}
pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;}
pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;}
img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;}
blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;}
table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;}
th,td {border:1px solid #dfe2e5; padding:6px 13px;}
tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;}
hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;}
footer {text-align:center; margin-top:40px; padding-top:20px; border-top:1px solid #eaecef; font-size:.9em; color:#586069;}
footer a {color:#0366d6;}
`;

async function parseRepoIdentifier(identifier) {
    // ... (this function remains the same)
    if (!identifier) { throw new Error("Repository identifier argument is missing."); } try { const url = new URL(identifier); const hostname = url.hostname.toLowerCase(); const pathParts = url.pathname.split('/').filter(Boolean); if (pathParts.length < 2) { throw new Error(`URL path does not seem to contain enough segments for a repository: ${url.pathname}`); } if (hostname === 'github.com') { return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1], originalIdentifier: identifier }; } else if (hostname === 'gitlab.com') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } else if (url.protocol === 'https:') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); console.warn(`Processing unknown host '${hostname}' using GitLab-like URL pattern for raw files.`); return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } } catch (e) { if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) { console.warn(`URL parsing attempt failed for '${identifier}': ${e.message}. Will try as 'user/repo'.`); } } if (identifier.includes('://')) { throw new Error(`Invalid repository identifier: '${identifier}'. Full URLs must be valid. For 'user/repo' shorthand, do not include protocol.`); } const parts = identifier.split('/'); if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) { return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier }; } throw new Error(`Could not parse repository identifier: '${identifier}'. Please use 'username/repository' format or a full HTTPS URL.`);
}

async function tryFetchForProvider(providerRepoInfo, branches, filePath) {
    // ... (this function remains the same)
    let lastBranchError = null; for (const branch of branches) { let readmeUrl; const repoDisplayPath = providerRepoInfo.type === 'github' ? `${providerRepoInfo.user}/${providerRepoInfo.repoName}` : `${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`; if (providerRepoInfo.type === 'github') { readmeUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`; } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') { readmeUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`; } else { return { content: null, error: new Error(`Internal error: Unsupported provider type: ${providerRepoInfo.type}`) }; } console.log(`Attempting: ${readmeUrl}`); try { const response = await fetch(readmeUrl); if (response.ok) { return { content: await response.text(), error: null }; } if (response.status === 404) { lastBranchError = new Error(`${filePath} not found on branch '${branch}' for ${repoDisplayPath} at ${providerRepoInfo.host}`); console.warn(lastBranchError.message); } else { throw new Error(`Failed to fetch ${filePath} from ${readmeUrl}. Status: ${response.status} ${response.statusText}`); } } catch (fetchError) { lastBranchError = new Error(`Network/fetch error for ${readmeUrl}: ${fetchError.message}`); console.warn(lastBranchError.message); return { content: null, error: lastBranchError }; } } return { content: null, error: lastBranchError || new Error(`${filePath} not found on any attempted branch for ${repoDisplayPath} at ${providerRepoInfo.host}.`) };
}

async function fetchReadmeContent(repoInfo) {
    // ... (this function remains the same)
    const filePath = 'README.md'; if (repoInfo.type === 'user_slash_repo') { console.log(`Input '${repoInfo.originalIdentifier}' is 'username/repository' shorthand.`); console.log("Attempting to resolve on GitHub (github.com)..."); const githubInfo = { type: 'github', host: 'github.com', user: repoInfo.user, repoName: repoInfo.repoName, originalIdentifier: repoInfo.originalIdentifier }; let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; console.warn(`GitHub attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); console.log("Attempting to resolve on GitLab (gitlab.com)..."); const gitlabInfo = { type: 'gitlab', host: 'gitlab.com', userOrGroupPath: repoInfo.user, repoName: repoInfo.repoName, originalIdentifier: repoInfo.originalIdentifier }; result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; console.warn(`GitLab.com attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); throw new Error(`Could not resolve '${repoInfo.originalIdentifier}' on GitHub or GitLab.com, or ${filePath} not found on any tried branch.`); } else { const result = await tryFetchForProvider(repoInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; throw result.error || new Error(`Could not find ${filePath} for '${repoInfo.originalIdentifier}' on any of the branches: ${CHECK_BRANCHES_ORDER.join(', ')}.`); }
}

async function generateSite(readmeContent, pageTitleBase, outputDir, repoOriginalIdentifier, ogImageUrlCli) {
    // ... (this function remains largely the same, receives null for repoOriginalIdentifier in local mode)
    console.log(`Generating site in directory: ${outputDir}`); try { await fs.mkdir(outputDir, { recursive: true }); } catch (error) { throw new Error(`Failed to create output directory '${outputDir}': ${error.message}`); } const htmlContent = marked.parse(readmeContent); const sitePageTitle = pageTitleBase; let ogUrlValue = ''; if (repoOriginalIdentifier && (repoOriginalIdentifier.startsWith('https://') || repoOriginalIdentifier.startsWith('http://'))) { try { new URL(repoOriginalIdentifier); ogUrlValue = repoOriginalIdentifier; } catch (e) { console.warn(`Original identifier '${repoOriginalIdentifier}' is not a valid URL for og:url. Omitting.`); } } let faviconPathInHtml = ''; let ogImageMetaTagUrl = ''; try { const __filename = fileURLToPath(import.meta.url); const __dirname = path.dirname(__filename); const sourceDefaultImagePath = path.join(__dirname, 'assets', DEFAULT_IMAGE_FILENAME); await fs.access(sourceDefaultImagePath); const destDefaultImagePath = path.join(outputDir, DEFAULT_IMAGE_FILENAME); await fs.copyFile(sourceDefaultImagePath, destDefaultImagePath); faviconPathInHtml = DEFAULT_IMAGE_FILENAME; ogImageMetaTagUrl = DEFAULT_IMAGE_FILENAME; console.log(`Using default image for favicon and as fallback OG image: ${DEFAULT_IMAGE_FILENAME}`); } catch (e) { console.warn(`Warning: Could not copy or access default image '${DEFAULT_IMAGE_FILENAME}'. Favicon and default OG image may be missing. Error: ${e.message}`); } if (ogImageUrlCli) { ogImageMetaTagUrl = ogImageUrlCli; console.log(`Using custom image for OG/Twitter previews: ${ogImageUrlCli}`); } const finalHtml = HTML_TEMPLATE .replace(/{{PAGE_TITLE}}/g, sitePageTitle) .replace(/{{OG_URL}}/g, ogUrlValue) .replace(/{{FAVICON_URL}}/g, faviconPathInHtml) .replace(/{{OG_IMAGE_URL}}/g, ogImageMetaTagUrl) .replace('{{CONTENT}}', htmlContent); try { await fs.writeFile(path.join(outputDir, 'index.html'), finalHtml); console.log(`Successfully wrote index.html`); } catch (error) { throw new Error(`Failed to write index.html: ${error.message}`); } try { await fs.writeFile(path.join(outputDir, 'style.css'), CSS_STYLES); console.log(`Successfully wrote style.css`); } catch (error) { throw new Error(`Failed to write style.css: ${error.message}`); }
}

function isLikelyRepoIdentifier(arg) {
    // Simple check: if it contains a slash (user/repo) or starts with http/https, it's likely a repo ID.
    // This means a single-word output directory for local mode won't be mistaken.
    return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://');
}

async function main() {
    const rawArgs = process.argv.slice(2);
    let repoIdentifierArg = null;
    let outputDirArg = DEFAULT_OUTPUT_DIR;
    let imageUrlArg = null;
    let localMode = false;
    const localReadmePath = 'README.md'; // Standard local README filename

    // Parse --image flag first
    const imageFlagIndex = rawArgs.indexOf('--image');
    if (imageFlagIndex !== -1) {
        if (imageFlagIndex + 1 < rawArgs.length && !rawArgs[imageFlagIndex + 1].startsWith('--')) {
            imageUrlArg = rawArgs[imageFlagIndex + 1];
            rawArgs.splice(imageFlagIndex, 2); // Remove flag and its value
        } else {
            console.warn("Warning: --image flag provided without a valid URL. Ignoring flag.");
            rawArgs.splice(imageFlagIndex, 1); // Remove only the flag
        }
    }

    // Determine mode and positional arguments from remaining rawArgs
    if (rawArgs.length === 0) {
        localMode = true; // `readmesite` -> local mode, default outputDir
    } else if (rawArgs.length === 1) {
        if (isLikelyRepoIdentifier(rawArgs[0])) {
            repoIdentifierArg = rawArgs[0]; // `readmesite user/repo` or `readmesite http://...`
            // outputDirArg remains DEFAULT_OUTPUT_DIR
        } else {
            localMode = true;
            outputDirArg = rawArgs[0]; // `readmesite myoutput` -> local mode, custom outputDir
        }
    } else { // rawArgs.length >= 2
        repoIdentifierArg = rawArgs[0]; // `readmesite user/repo myoutput`
        outputDirArg = rawArgs[1];
        // Further arguments are ignored for now
    }

    // Show help and exit if no action can be determined (e.g. bad invocation)
    // This condition is effectively: if not localMode AND no repoIdentifierArg was successfully parsed.
    // However, with the logic above, either localMode is true, or repoIdentifierArg is set if any args are present.
    // The primary "error" or "help" scenario is invoking with truly problematic arguments not caught above,
    // or if we wanted `readmesite --help`.
    // For now, if localMode is true or repoIdentifierArg is set, we proceed.
    // The help message below is now primarily for when the script is invoked with specifically problematic args
    // that bypass the initial parsing into local/remote mode, OR if the user just runs `readmesite` with no args
    // AND we decide that should show help instead of defaulting to local build immediately.
    // Let's adjust: If no args at all, default to local. If args are present but don't fit, show help.
    // The existing argument parsing handles `readmesite` (no args) by setting `localMode = true`.

    if (!localMode && !repoIdentifierArg) { // This case should ideally not be hit if parsing logic above is sound
        console.error("Error: Could not determine operation. Please provide a repository identifier or run in a directory with a README.md for local mode.\n");
        // Fall through to help display
    }
    
    // If neither local mode is active nor a remote identifier is provided after parsing, show help.
    // This condition is a bit tricky because `readmesite` alone defaults to local mode.
    // The main error condition for exiting with help is if `repoIdentifierArg` was expected for remote mode but is missing/invalid.
    // The `parseRepoIdentifier` function will throw if `repoIdentifierArg` is invalid for remote mode.
    // So the help display here is mainly for `readmesite --help` (not implemented) or truly ambiguous calls.
    // Let's refine the usage message display slightly. We'll display help if arguments are confusing,
    // but `readmesite` alone or `readmesite <output>` will proceed to local mode.
    // `readmesite <repo>` or `readmesite <repo> <output>` will proceed to remote.

    // The actual check for exiting with help should be if after all parsing, we have no task.
    // This is covered by `localMode` being true or `repoIdentifierArg` being set.

    try {
        if (localMode) {
            console.log(`Local mode: Processing '${localReadmePath}' in current directory.`);
            console.log(`Output directory: '${path.resolve(outputDirArg)}'`);
            if (imageUrlArg) {
                console.log(`Using custom image for social previews: ${imageUrlArg}`);
            }

            let readmeContent;
            try {
                readmeContent = await fs.readFile(localReadmePath, 'utf-8');
            } catch (readError) {
                if (readError.code === 'ENOENT') {
                    throw new Error(`Local mode error: '${localReadmePath}' not found in the current directory.`);
                }
                throw new Error(`Local mode error: Could not read '${localReadmePath}': ${readError.message}`);
            }
            
            const pageTitle = path.basename(process.cwd()); // Use current directory name as title
            // For local mode, repoOriginalIdentifier (for og:url) is null.
            // og:url will be empty unless a future --site-url flag is added.
            await generateSite(readmeContent, pageTitle, path.resolve(outputDirArg), null, imageUrlArg);

        } else { // Remote mode
            if (!repoIdentifierArg) { // Should have been caught if arguments were truly missing for remote.
                 // This is a fallback; primary help is now if no mode can be determined.
                console.error("Error: Repository identifier is required for remote mode.\n");
                // Print usage message (see refined version below for when no args at all)
                process.exit(1);
            }
            const repoInfo = await parseRepoIdentifier(repoIdentifierArg);
            let logIdentifier = repoInfo.originalIdentifier;
            if (repoInfo.type === 'user_slash_repo') {
                 logIdentifier = `${repoInfo.user}/${repoInfo.repoName}`;
            }
            console.log(`Remote mode: Processing repository ${logIdentifier} (Provider: ${repoInfo.type}, Host: ${repoInfo.host || 'N/A'})`);
            if (imageUrlArg) {
                console.log(`Using custom image for social previews: ${imageUrlArg}`);
            }

            const readmeContent = await fetchReadmeContent(repoInfo);
            console.log("README.md fetched successfully.");

            await generateSite(readmeContent, repoInfo.repoName, path.resolve(outputDirArg), repoInfo.originalIdentifier, imageUrlArg);
        }

        console.log("\n✅ Site generation complete!");
        console.log(`\nStatic site files are located in: ${path.resolve(outputDirArg)}`);
        console.log("\n🚀 To deploy (example for Cloudflare Pages):");
        console.log("   If using Cloudflare Pages Git integration, commit the output directory.");
        console.log("   If building on Cloudflare Pages, your build command could be: npx readmesite");
        console.log("   Or for direct deploy: wrangler pages deploy ", path.basename(path.resolve(outputDirArg)));


    } catch (error) {
        console.error(`\n❌ Error: ${error.message}`);
        // Display usage on certain types of errors or if identifier was missing from the start
        if (!localMode && !repoIdentifierArg) { // Re-check if we somehow got here without a target
             console.log("\nUsage for remote repository:");
             console.log("  readmesite <repository_identifier> [output_directory] [--image <image_url>]\n");
             console.log("Usage for local README.md (in current directory):");
             console.log("  readmesite [output_directory] [--image <image_url>]\n");
             console.log("If no arguments are given, it processes ./README.md into ./public.\n");
             console.log("Examples:");
             console.log("  readmesite");
             console.log("  readmesite my_local_docs");
             console.log("  readmesite bquast/readmesite");
             console.log("  readmesite https://github.com/user/repo public_html --image <url>\n");
        }
        if (error.cause) { 
             console.error(`Cause: ${error.cause}`);
        }
        process.exit(1);
    }
}

// Check if script is run with no arguments at all (excluding --image if it was the only thing)
// This is to provide help text if the user just types `readmesite` and expects info,
// or if initial argument parsing leads to an invalid state.
// The refined logic within main now handles `readmesite` (no args) as defaulting to local mode.
// The error message when `repoIdentifierArg` is missing for remote mode in `main` is now the primary help trigger
// if arguments are insufficient for the inferred mode.

// Let's ensure the initial check for `!repoIdentifierArg` in the old remote block is better handled.
// The main function's top-level argument parsing logic now determines `localMode` or sets `repoIdentifierArg`.
// If after that, `!localMode && !repoIdentifierArg` is true, it implies a parsing failure or insufficient args
// for remote mode. The current help display within the catch block for this specific condition is reasonable.
// For a truly 'no args' help, we could add an explicit check at the very start of main,
// but the current structure (default to local if 0 args after flags) is also a valid UX.

main();
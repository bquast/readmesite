#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import { fileURLToPath } from 'url';

const DEFAULT_OUTPUT_DIR = '.';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_FILENAME = 'readmesite-og-default.png';
const THEME_STORE_BASE_URL = 'https://store.readme.site/themes';
const LOCAL_THEMES_DIR = '.';

const initialArgsForVerbose = process.argv.slice(2);
const verboseArgIndexForIsVerbose = initialArgsForVerbose.indexOf('--verbose');
const isVerbose = verboseArgIndexForIsVerbose !== -1;
if (isVerbose) {
    process.env.VERBOSE_READMESITE = 'true';
}

// Updated HTML_TEMPLATE with EXTRA_LINKS_HTML moved
const HTML_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{PAGE_TITLE}}</title>
    {{GOOGLE_ANALYTICS_SCRIPT}}
    <meta property="og:type" content="website">
    <meta property="og:url" content="{{OG_URL}}">
    <meta property="og:title" content="{{PAGE_TITLE}}">
    <meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta property="og:image" content="{{OG_IMAGE_URL}}">
    <meta property="og:site_name" content="{{PAGE_TITLE}}">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="{{OG_URL}}">
    <meta name="twitter:title" content="{{PAGE_TITLE}}">
    <meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta name="twitter:image" content="{{OG_IMAGE_URL}}">
    <link rel="stylesheet" href="style.css" id="readmesite-theme-stylesheet">
    <link rel="icon" href="{{FAVICON_URL}}" type="image/png">
</head>
<body>
    <main class="container">
        {{CONTENT}}
        <hr class="readmesite-footer-separator">
        {{EXTRA_LINKS_HTML}}
        <div class="readmesite-footer">
            <p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a>{{FOOTER_REPO_SOURCE_HTML}}</p>
        </div>
    </main>
    {{BROWSER_CONSOLE_LOG_SCRIPT}}
</body>
</html>`;

const CSS_STYLES = `body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;} .container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);} h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;} h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;} p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;} a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;} code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;} pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;} pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;} img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;} blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;} table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;} th,td {border:1px solid #dfe2e5; padding:6px 13px;} tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;} hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;} hr.readmesite-footer-separator {height: 2px; background-color: #d1d5da; border: none; margin-top: 48px; margin-bottom: 10px;} div.readmesite-footer {text-align: center; font-size: 0.85em; color: #586069; padding-bottom: 10px; margin-top: 10px;} div.readmesite-footer p { margin: 0; } div.readmesite-footer a {color: #0366d6; text-decoration: none;} div.readmesite-footer a:hover {text-decoration: underline;} .readmesite-extra-links { text-align: center; margin-top: 10px; margin-bottom: 15px; font-size: 0.9em; color: #586069; } .readmesite-extra-links p { margin: 0; } .readmesite-extra-links a { color: #0366d6; text-decoration: none; margin: 0 5px; } .readmesite-extra-links a:hover { text-decoration: underline; } .readmesite-extra-links strong { margin: 0 5px; font-weight: bold; }`;

function sanitizeUrlForPublicDisplay(urlString) { if (!urlString || typeof urlString !== 'string' || (!urlString.startsWith('http:') && !urlString.startsWith('https://'))) { return urlString; } try { const urlObj = new URL(urlString); return `${urlObj.protocol}//${urlObj.hostname}${urlObj.port ? ':' + urlObj.port : ''}${urlObj.pathname}${urlObj.search}${urlObj.hash}`; } catch (e) { if (isVerbose) console.warn(`Warning: Could not sanitize URL '${urlString}': ${e.message}`); return urlString; } }
function getPlainTextFromInlineTokens(inlineTokens) { return inlineTokens.map(token => { if (token.type === 'text' || token.type === 'codespan') { return token.raw || token.text; } if (token.tokens && token.tokens.length > 0) { return getPlainTextFromInlineTokens(token.tokens); } return token.raw || token.text || ''; }).join(''); }
function extractFirstH1(markdownContent) { if (!markdownContent) return null; try { const tokens = marked.lexer(markdownContent); const firstH1Token = tokens.find(token => token.type === 'heading' && token.depth === 1); if (firstH1Token && firstH1Token.tokens) { let title = getPlainTextFromInlineTokens(firstH1Token.tokens).trim(); title = title.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#039;/g, "'"); return title || null; } } catch (e) { if (isVerbose) console.warn(`Warning: Could not extract H1 title: ${e.message}`); } return null; }
async function parseRepoIdentifier(identifier) { if (!identifier) { throw new Error("Repository identifier argument is missing."); } try { const url = new URL(identifier); const hostname = url.hostname.toLowerCase(); const pathParts = url.pathname.split('/').filter(Boolean); if (pathParts.length < 2) { throw new Error(`URL path does not seem to contain enough segments: ${url.pathname}`); } if (hostname === 'github.com') { return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1].replace(/.git$/, ''), originalIdentifier: identifier }; } else if (hostname === 'gitlab.com') { const repoName = pathParts[pathParts.length - 1].replace(/.git$/, ''); const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } else if (url.protocol === 'https:') { const repoName = pathParts[pathParts.length - 1].replace(/.git$/, ''); const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); if (isVerbose) console.log(`Info: Processing unknown host '${hostname}' like GitLab.`); return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } } catch (e) { if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) { if (isVerbose) console.warn(`URL parse failed for '${identifier}': ${e.message}. Trying 'user/repo'.`); } } if (identifier.includes('://')) { throw new Error(`Invalid repo identifier: '${identifier}'.`); } const parts = identifier.split('/'); if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) { return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier }; } throw new Error(`Could not parse repo identifier: '${identifier}'. Use 'user/repo' or a full URL.`); }
async function tryFetchForProvider(providerRepoInfo, branches, filePath) { let lastBranchError = null; for (const branch of branches) { let readmeUrl; const repoDisplayPath = providerRepoInfo.type === 'github' ? `${providerRepoInfo.user}/${providerRepoInfo.repoName}` : `${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`; if (providerRepoInfo.type === 'github') { readmeUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`; } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') { readmeUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`; } else { return { content: null, branch: null, error: new Error(`Internal error: Unsupported provider: ${providerRepoInfo.type}`) }; } if (isVerbose) console.log(`Attempting: ${readmeUrl}`); try { const response = await fetch(readmeUrl); if (response.ok) { return { content: await response.text(), branch: branch, error: null }; } if (response.status === 404) { lastBranchError = new Error(`${filePath} not found on branch '${branch}'`); if (isVerbose) console.warn(lastBranchError.message); } else { throw new Error(`Failed to fetch ${filePath}. Status: ${response.status} ${response.statusText}`); } } catch (fetchError) { lastBranchError = new Error(`Network error for ${readmeUrl}: ${fetchError.message}`); console.warn(lastBranchError.message); return { content: null, branch: null, error: lastBranchError }; } } return { content: null, branch: null, error: lastBranchError || new Error(`${filePath} not found on any branch for ${repoDisplayPath}.`) }; }
async function fetchReadmeContent(initialRepoInfo) { const filePath = 'README.md'; if (initialRepoInfo.type === 'user_slash_repo') { if (isVerbose) console.log(`Input '${initialRepoInfo.originalIdentifier}' is shorthand, trying GitHub...`); const githubInfo = { type: 'github', host: 'github.com', user: initialRepoInfo.user, repoName: initialRepoInfo.repoName, originalIdentifier: initialRepoInfo.originalIdentifier }; let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) { return { readmeContent: result.content, actualSourceRepoInfo: githubInfo, branch: result.branch }; } console.warn(`GitHub failed: ${result.error ? result.error.message : "Not found"}. Trying GitLab...`); const gitlabInfo = { type: 'gitlab', host: 'gitlab.com', userOrGroupPath: initialRepoInfo.user, repoName: initialRepoInfo.repoName, originalIdentifier: initialRepoInfo.originalIdentifier }; result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) { return { readmeContent: result.content, actualSourceRepoInfo: gitlabInfo, branch: result.branch }; } throw new Error(`Could not resolve '${initialRepoInfo.originalIdentifier}' on GitHub or GitLab.com.`); } else { const result = await tryFetchForProvider(initialRepoInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) { return { readmeContent: result.content, actualSourceRepoInfo: initialRepoInfo, branch: result.branch }; } throw result.error || new Error(`Could not find ${filePath} for '${initialRepoInfo.originalIdentifier}'.`); } }
async function getLocalGitRepoInfo() { try { const gitConfigPath = path.join(process.cwd(), '.git', 'config'); const configContent = await fs.readFile(gitConfigPath, 'utf-8'); const originUrlMatch = configContent.match(/\[remote\s+"origin"\]\s*[^\[]*?\s*url\s*=\s*([^\s]+)/); if (originUrlMatch && originUrlMatch[1]) { let url = originUrlMatch[1]; url = url.replace(/^git@([^:]+):(.+?)(\.git)?$/, 'https://$1/$2'); if (url.endsWith('.git')) url = url.substring(0, url.length - 4); if (url.startsWith('http://')) url = 'https://' + url.substring(7); if (!url.startsWith('https://')) { if (isVerbose) console.log(`Non-standard remote URL: ${originUrlMatch[1]}`); return null; } let displayName = url; try { const parsedUrl = new URL(url); const pathParts = parsedUrl.pathname.split('/').filter(Boolean); displayName = pathParts.length >= 2 ? `${pathParts[pathParts.length - 2]}/${pathParts[pathParts.length - 1]}` : pathParts[0] || url; } catch (e) { /* use full URL */ } return { url: url, name: displayName }; } } catch (e) { if (isVerbose) console.log(`No local git info. (${e.message})`); } return null; }
async function fetchOrReadContent(pathOrUrl, isThemeAsset = false) { if (!pathOrUrl) return null; const isHttpUrl = pathOrUrl.startsWith('http:') || pathOrUrl.startsWith('https://'); if (isVerbose) console.log(`Getting content from ${isHttpUrl ? 'URL' : 'path'}: ${pathOrUrl}`); try { if (isHttpUrl) { const response = await fetch(pathOrUrl); if (!response.ok) { if (isThemeAsset && response.status === 404) return null; throw new Error(`Workspace failed ${pathOrUrl}. Status: ${response.status}`); } return await response.text(); } else { return await fs.readFile(pathOrUrl, 'utf-8'); } } catch (e) { if (isThemeAsset) { if (isVerbose) console.warn(`Theme asset not found/read '${pathOrUrl}': ${e.message}`); return null; } throw new Error(`Could not read/fetch '${pathOrUrl}': ${e.message}`); } }

async function fetchOtherMdFilesGitHub(user, repoName, branch) {
    const apiUrl = `https://api.github.com/repos/${user}/${repoName}/contents/?ref=${branch}`;
    const otherFiles = {}; // { 'filename.md': 'content' }
    if (isVerbose) console.log(`Attempting to list files from: ${apiUrl}`);
    try {
        const response = await fetch(apiUrl, { headers: { 'Accept': 'application/vnd.github.v3+json' } });
        if (!response.ok) {
            console.warn(`Warning: GitHub API list failed (Status: ${response.status}). Proceeding with README only.`);
            return otherFiles;
        }
        const filesList = await response.json();
        const mdFileNames = filesList
            .filter(file => file.type === 'file' && file.name.toLowerCase().endsWith('.md') && file.name.toLowerCase() !== 'readme.md')
            .map(file => file.name);

        if (mdFileNames.length > 0 && isVerbose) console.log(`Found other MD files: ${mdFileNames.join(', ')}`);

        for (const fileName of mdFileNames) {
            const rawUrl = `https://raw.githubusercontent.com/${user}/${repoName}/${branch}/${fileName}`;
            if (isVerbose) console.log(`Workspaceing: ${rawUrl}`);
            try {
                const fileResponse = await fetch(rawUrl);
                if (fileResponse.ok) { otherFiles[fileName] = await fileResponse.text(); }
                else { console.warn(`Warning: Failed to fetch ${fileName} (Status: ${fileResponse.status})`); }
            } catch (fetchError) { console.warn(`Warning: Fetch error for ${fileName}: ${fetchError.message}`); }
        }
    } catch (apiError) { console.warn(`Warning: GitHub API error: ${apiError.message}. Proceeding with README only.`); }
    return otherFiles;
}

async function generateSinglePage(markdownContent, pageTitle, outputDir, outputFilename, ogUrlToUse, ogImageUrl, gaPropertyId, customHtmlTemplate, cssFileToLink, footerLinkHref, footerLinkText, allMdFiles = [], currentFileBase = '') {
    if (isVerbose) console.log(`Generating page "${pageTitle}" -> ${path.join(outputDir, outputFilename)}`);
    const htmlContent = marked.parse(markdownContent);
    const faviconUrl = DEFAULT_IMAGE_FILENAME;
    let gaScriptHtml = '';
    if (gaPropertyId) { gaScriptHtml = `<script async src="https://www.googletagmanager.com/gtag/js?id=${gaPropertyId}"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','${gaPropertyId}');</script>`; }
    let displayPathForConsole = "N/A"; let repoUrl = footerLinkHref || ogUrlToUse || "";
    if (repoUrl) { try { const u = new URL(repoUrl); let p = u.pathname.endsWith('.git') ? u.pathname.slice(0, -4) : u.pathname; p = p.startsWith('/') ? p.substring(1) : p; displayPathForConsole = `${u.hostname}/${p}`; } catch (e) { displayPathForConsole = repoUrl; } } else if (footerLinkText) { displayPathForConsole = footerLinkText; }
    const safeConsolePath = displayPathForConsole.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${}');
    const browserConsoleLogScript = `<script> console.log(\`Page generated by READMEsite (https://readme.site/) from ${safeConsolePath}\`); </script>`;
    let footerRepoHtml = '';
    if (footerLinkHref && footerLinkText) { footerRepoHtml = ` from <a href="${footerLinkHref}" target="_blank" rel="noopener noreferrer">${footerLinkText}</a>`; }
    else if (footerLinkText) { footerRepoHtml = ` from ${footerLinkText}`; }
    let extraLinksHtml = '';
    if (allMdFiles.length > 1) {
        extraLinksHtml = '<div class="readmesite-extra-links"><p>';
        const links = allMdFiles.map(file => {
            const base = path.basename(file, '.md');
            const htmlFile = base.toLowerCase() === 'readme' ? 'index.html' : base + '.html';
            const linkText = base;
            if (base.toLowerCase() === currentFileBase.toLowerCase()) { return `<strong>${linkText}</strong>`; }
            else { return `<a href="${htmlFile}">${linkText}</a>`; }
        });
        extraLinksHtml += links.join(' | ');
        extraLinksHtml += '</p></div>';
    }
    let finalHtmlTemplate = customHtmlTemplate || HTML_TEMPLATE;
    finalHtmlTemplate = finalHtmlTemplate.replace(/<link rel="stylesheet" href=".*?" id="readmesite-theme-stylesheet">/, `<link rel="stylesheet" href="${cssFileToLink}" id="readmesite-theme-stylesheet">`);
    const finalHtml = finalHtmlTemplate.replace(/{{PAGE_TITLE}}/g, pageTitle).replace('{{GOOGLE_ANALYTICS_SCRIPT}}', gaScriptHtml).replace(/{{OG_URL}}/g, ogUrlToUse || '').replace(/{{FAVICON_URL}}/g, faviconUrl).replace(/{{OG_IMAGE_URL}}/g, ogImageUrl || faviconUrl).replace('{{FOOTER_REPO_SOURCE_HTML}}', footerRepoHtml).replace('{{BROWSER_CONSOLE_LOG_SCRIPT}}', browserConsoleLogScript).replace('{{EXTRA_LINKS_HTML}}', extraLinksHtml).replace('{{CONTENT}}', htmlContent);
    try { await fs.writeFile(path.join(outputDir, outputFilename), finalHtml); }
    catch (error) { throw new Error(`Failed to write ${outputFilename}: ${error.message}`); }
}

function isLikelyRepoIdentifier(arg) { return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://'); }
function isUrl(str) { return str.startsWith('http:') || str.startsWith('https://') || str.startsWith('file://'); }

async function main() {
    let rawArgs = process.argv.slice(2);
    if (rawArgs.includes('--verbose')) { if (!process.env.VERBOSE_READMESITE) process.env.VERBOSE_READMESITE = 'true'; rawArgs = rawArgs.filter(arg => arg !== '--verbose'); if (isVerbose) console.log("Verbose mode enabled."); }
    let repoIdentifierArg = null, outputDirArg = DEFAULT_OUTPUT_DIR, imageUrlArg = null, gaPropertyIdArg = null, themeArg = null, paletteArg = null;
    let localMode = false; const remainingArgs = [];
    for (let i = 0; i < rawArgs.length; i++) {
        const arg = rawArgs[i];
        if (arg === '--image') { imageUrlArg = (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) ? rawArgs[++i] : (console.warn("Warning: --image needs URL."), null); }
        else if (arg === '--ga') { gaPropertyIdArg = (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) ? rawArgs[++i] : (console.warn("Warning: --ga needs ID."), null); }
        else if (arg === '--theme') { themeArg = (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) ? rawArgs[++i] : (console.warn("Warning: --theme needs name/URL."), null); }
        else if (arg === '--palette') { paletteArg = (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) ? rawArgs[++i] : (console.warn("Warning: --palette needs name."), null); }
        else { remainingArgs.push(arg); }
    }
    rawArgs = remainingArgs;
    if (rawArgs.length === 0) { localMode = true; }
    else if (rawArgs.length === 1) { if (isLikelyRepoIdentifier(rawArgs[0])) { repoIdentifierArg = rawArgs[0]; } else { localMode = true; outputDirArg = rawArgs[0]; } }
    else { repoIdentifierArg = rawArgs[0]; outputDirArg = rawArgs[1]; }
    if (!localMode && !repoIdentifierArg && !themeArg) { console.error("Error: Could not determine operation. Provide repo or use local mode.\nUsage...\n"); process.exit(1); }

    try {
        const resolvedOutputDir = path.resolve(outputDirArg);
        await fs.mkdir(resolvedOutputDir, { recursive: true });
        let ogUrlToUse = '', footerLinkHref = null, footerLinkText = null;
        let customCssContent = null, customHtmlTemplate = null;
        let resolvedThemeCssFilename = 'style.css';
        // --- Theme Handling ---
        if (themeArg) {
            let themeName = themeArg;
            if (paletteArg) themeName = `${themeArg}-${paletteArg}`;
            resolvedThemeCssFilename = `${themeName}.css`;
            let cssUrl, htmlUrl;
            if (isUrl(themeArg)) {
                cssUrl = themeArg.endsWith('.css') ? themeArg : (new URL(`${themeName}.css`, themeArg.endsWith('/') ? themeArg : themeArg + "/")).toString();
                htmlUrl = cssUrl.replace(/\.css$/, '.html');
                resolvedThemeCssFilename = path.basename(cssUrl);
            } else {
                cssUrl = `${THEME_STORE_BASE_URL}/${resolvedThemeCssFilename}`;
                htmlUrl = `${THEME_STORE_BASE_URL}/${themeName}.html`;
            }
            customCssContent = await fetchOrReadContent(cssUrl, true);
            customHtmlTemplate = await fetchOrReadContent(htmlUrl, true);
            if (!customCssContent) { // Try local
                cssUrl = path.join(LOCAL_THEMES_DIR, resolvedThemeCssFilename);
                htmlUrl = path.join(LOCAL_THEMES_DIR, `${themeName}.html`);
                customCssContent = await fetchOrReadContent(cssUrl, true);
                if (!customHtmlTemplate) customHtmlTemplate = await fetchOrReadContent(htmlUrl, true);
            }
            if (!customCssContent) throw new Error(`Theme CSS for '${themeName}' not found.`);
            if (isVerbose) console.log(`Using theme: ${themeName}`);
        }
        // --- End Theme Handling ---
        let defaultOgImage = ''; try { const __filename = fileURLToPath(import.meta.url); const __dirname = path.dirname(__filename); const srcImg = path.join(__dirname, 'assets', DEFAULT_IMAGE_FILENAME); await fs.access(srcImg); await fs.copyFile(srcImg, path.join(resolvedOutputDir, DEFAULT_IMAGE_FILENAME)); defaultOgImage = DEFAULT_IMAGE_FILENAME; } catch (e) { console.warn(`Warn: Default image copy failed: ${e.message}`); }
        const finalOgImageUrl = imageUrlArg || defaultOgImage;
        const cssFileToWrite = resolvedThemeCssFilename || 'style.css';
        await fs.writeFile(path.join(resolvedOutputDir, cssFileToWrite), customCssContent || CSS_STYLES);
        if (isVerbose) console.log(`Wrote ${cssFileToWrite}`);

        let allMdContent = {}; // { 'filename.md': 'content' }
        let allMdFiles = [];

        if (localMode) {
            console.log(`Processing local files -> '${resolvedOutputDir}'`);
            const dirents = await fs.readdir(process.cwd(), { withFileTypes: true });
            const localFiles = dirents.filter(d => d.isFile() && d.name.toLowerCase().endsWith('.md')).map(d => d.name);
            if (!localFiles.find(f => f.toLowerCase() === 'readme.md')) throw new Error("Local mode error: 'README.md' not found.");
            for (const f of localFiles) { allMdContent[f] = await fs.readFile(f, 'utf-8'); }
            const gitInfo = await getLocalGitRepoInfo();
            if (gitInfo) { ogUrlToUse = sanitizeUrlForPublicDisplay(gitInfo.url); footerLinkHref = ogUrlToUse; footerLinkText = gitInfo.name; }
        } else { // Remote Mode
            const initialRepoInfo = await parseRepoIdentifier(repoIdentifierArg);
            ogUrlToUse = (initialRepoInfo.originalIdentifier.startsWith('http')) ? sanitizeUrlForPublicDisplay(initialRepoInfo.originalIdentifier) : '';
            console.log(`Processing remote '${initialRepoInfo.originalIdentifier}' -> '${resolvedOutputDir}'`);
            const { readmeContent, actualSourceRepoInfo, branch } = await fetchReadmeContent(initialRepoInfo);
            allMdContent['README.md'] = readmeContent;
            if (isVerbose) console.log(`README fetched from ${actualSourceRepoInfo.host} (branch: ${branch || 'unknown'})`);
            if (actualSourceRepoInfo.type === 'github' && branch) {
                const others = await fetchOtherMdFilesGitHub(actualSourceRepoInfo.user, actualSourceRepoInfo.repoName, branch);
                Object.assign(allMdContent, others);
            } else if (actualSourceRepoInfo.type !== 'github') { console.warn("Warn: Other .md file discovery only supported for GitHub. Using README only."); }
            if (actualSourceRepoInfo.type === 'github') { footerLinkHref = `https://github.com/${actualSourceRepoInfo.user}/${actualSourceRepoInfo.repoName}`; footerLinkText = `github.com/${actualSourceRepoInfo.user}/${actualSourceRepoInfo.repoName}`; }
            else { footerLinkHref = `https://${actualSourceRepoInfo.host}/${actualSourceRepoInfo.userOrGroupPath}/${actualSourceRepoInfo.repoName}`; footerLinkText = `${actualSourceRepoInfo.host}/${actualSourceRepoInfo.userOrGroupPath}/${actualSourceRepoInfo.repoName}`; }
            ogUrlToUse = ogUrlToUse || footerLinkHref;
        }

        allMdFiles = Object.keys(allMdContent).sort((a, b) => a.toLowerCase() === 'readme.md' ? -1 : (b.toLowerCase() === 'readme.md' ? 1 : a.localeCompare(b)));
        if (allMdFiles.length === 0) throw new Error("No Markdown content found.");

        let defaultPageTitle = "READMEsite";
        if(localMode) {
            try { const pkg = JSON.parse(await fs.readFile('package.json', 'utf-8')); defaultPageTitle = pkg.name || defaultPageTitle; } catch (e) { defaultPageTitle = path.basename(process.cwd());}
        } else if (repoIdentifierArg) {
            try { const p = new URL(ogUrlToUse || "http://example.com/").pathname.split('/').filter(Boolean); defaultPageTitle = p[1] || p[0] || defaultPageTitle; } catch(e) {/*ignore*/}
        }


        for (const mdFile of allMdFiles) {
            const content = allMdContent[mdFile];
            const baseName = path.basename(mdFile, '.md');
            const title = extractFirstH1(content) || baseName || defaultPageTitle;
            const outputName = baseName.toLowerCase() === 'readme' ? 'index.html' : baseName + '.html';
            await generateSinglePage(content, title, resolvedOutputDir, outputName, ogUrlToUse, finalOgImageUrl, gaPropertyIdArg, customHtmlTemplate, cssFileToWrite, footerLinkHref, footerLinkText, allMdFiles, baseName);
        }

        console.log(`\n✅ Site generation complete! Files in: ${resolvedOutputDir}`);
        if (!process.env.CI) { console.log("\nDeployment Hints:\n  - For GitHub Pages, push the output directory to a 'gh-pages' branch.\n  - For Cloudflare Pages or Netlify, configure them to deploy the output directory.\n  - You can also serve it locally: 'npx serve " + path.basename(resolvedOutputDir) + "'"); }

    } catch (error) {
        console.error(`\n❌ Error: ${error.message}`);
        if (isVerbose && error.stack) console.error(error.stack);
        process.exit(1);
    }
}

main();
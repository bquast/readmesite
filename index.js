#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import { fileURLToPath } from 'url';

const DEFAULT_OUTPUT_DIR = 'public';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_FILENAME = 'readmesite-og-default.png';

const isVerbose = process.argv.includes('--verbose');

const HTML_TEMPLATE = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>{{PAGE_TITLE}}</title><meta property="og:type" content="website"><meta property="og:url" content="{{OG_URL}}"><meta property="og:title" content="{{PAGE_TITLE}}"><meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository."><meta property="og:image" content="{{OG_IMAGE_URL}}"><meta property="og:site_name" content="{{PAGE_TITLE}}"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:url" content="{{OG_URL}}"><meta name="twitter:title" content="{{PAGE_TITLE}}"><meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository."><meta name="twitter:image" content="{{OG_IMAGE_URL}}"><link rel="stylesheet" href="style.css"><link rel="icon" href="{{FAVICON_URL}}" type="image/png"></head><body><main class="container">{{CONTENT}}</main><footer><p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a>{{FOOTER_REPO_SOURCE}}</p></footer></body></html>`;
const CSS_STYLES = `body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;} .container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);} h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;} h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;} p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;} a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;} code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;} pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;} pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;} img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;} blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;} table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;} th,td {border:1px solid #dfe2e5; padding:6px 13px;} tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;} hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;} footer {text-align:center; margin-top:40px; padding-top:20px; border-top:1px solid #eaecef; font-size:.9em; color:#586069;} footer a {color:#0366d6;}`;

function getPlainTextFromInlineTokens(inlineTokens) { /* ... (same as previous) ... */ return inlineTokens.map(token => { if (token.type === 'text' || token.type === 'codespan') { return token.raw || token.text; } if (token.tokens && token.tokens.length > 0) { return getPlainTextFromInlineTokens(token.tokens); } return token.raw || token.text || ''; }).join(''); }
function extractFirstH1(markdownContent) { /* ... (same as previous) ... */ if (!markdownContent) return null; try { const tokens = marked.lexer(markdownContent); const firstH1Token = tokens.find(token => token.type === 'heading' && token.depth === 1); if (firstH1Token && firstH1Token.tokens) { let title = getPlainTextFromInlineTokens(firstH1Token.tokens).trim(); title = title.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#039;/g, "'"); return title || null; } } catch (e) { if (isVerbose) console.warn(`Warning: Could not extract H1 title from README: ${e.message}`); } return null; }
async function parseRepoIdentifier(identifier) { /* ... (same as previous) ... */ if (!identifier) { throw new Error("Repository identifier argument is missing."); } try { const url = new URL(identifier); const hostname = url.hostname.toLowerCase(); const pathParts = url.pathname.split('/').filter(Boolean); if (pathParts.length < 2) { throw new Error(`URL path does not seem to contain enough segments for a repository: ${url.pathname}`); } if (hostname === 'github.com') { return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1], originalIdentifier: identifier }; } else if (hostname === 'gitlab.com') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } else if (url.protocol === 'https:') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); if (isVerbose) console.log(`Info: Processing unknown host '${hostname}' using GitLab-like URL pattern.`); return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } } catch (e) { if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) { if (isVerbose) console.warn(`URL parsing attempt failed for '${identifier}': ${e.message}. Will try as 'user/repo'.`); } } if (identifier.includes('://')) { throw new Error(`Invalid repository identifier: '${identifier}'. Full URLs must be valid. For 'user/repo' shorthand, do not include protocol.`); } const parts = identifier.split('/'); if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) { return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier }; } throw new Error(`Could not parse repository identifier: '${identifier}'. Please use 'username/repository' format or a full HTTPS URL.`); }

async function tryFetchForProvider(providerRepoInfo, branches, filePath) {
    // ... (this function itself doesn't need to change its return signature,
    // but fetchReadmeContent will use providerRepoInfo if this call succeeds)
    let lastBranchError = null; for (const branch of branches) { let readmeUrl; const repoDisplayPath = providerRepoInfo.type === 'github' ? `${providerRepoInfo.user}/${providerRepoInfo.repoName}` : `${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`; if (providerRepoInfo.type === 'github') { readmeUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`; } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') { readmeUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`; } else { return { content: null, error: new Error(`Internal error: Unsupported provider type: ${providerRepoInfo.type}`) }; } if (isVerbose) console.log(`Attempting: ${readmeUrl}`); try { const response = await fetch(readmeUrl); if (response.ok) { return { content: await response.text(), error: null }; } if (response.status === 404) { lastBranchError = new Error(`${filePath} not found on branch '${branch}' for ${repoDisplayPath} at ${providerRepoInfo.host}`); if (isVerbose) console.warn(lastBranchError.message); } else { throw new Error(`Failed to fetch ${filePath} from ${readmeUrl}. Status: ${response.status} ${response.statusText}`); } } catch (fetchError) { lastBranchError = new Error(`Network/fetch error for ${readmeUrl}: ${fetchError.message}`); console.warn(lastBranchError.message); return { content: null, error: lastBranchError }; } } return { content: null, error: lastBranchError || new Error(`${filePath} not found on any attempted branch for ${repoDisplayPath} at ${providerRepoInfo.host}.`) };
}

async function fetchReadmeContent(initialRepoInfo) { // Renamed repoInfo to initialRepoInfo
    const filePath = 'README.md';
    if (initialRepoInfo.type === 'user_slash_repo') {
        if (isVerbose) console.log(`Input '${initialRepoInfo.originalIdentifier}' is 'username/repository' shorthand.`);
        
        if (isVerbose) console.log("Attempting to resolve on GitHub (github.com)...");
        const githubInfo = { type: 'github', host: 'github.com', user: initialRepoInfo.user, repoName: initialRepoInfo.repoName, originalIdentifier: initialRepoInfo.originalIdentifier };
        let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath);
        if (result.content) {
            return { readmeContent: result.content, actualSourceRepoInfo: githubInfo };
        }
        console.warn(`GitHub attempt for '${initialRepoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`);

        if (isVerbose) console.log("Attempting to resolve on GitLab (gitlab.com)...");
        const gitlabInfo = { type: 'gitlab', host: 'gitlab.com', userOrGroupPath: initialRepoInfo.user, repoName: initialRepoInfo.repoName, originalIdentifier: initialRepoInfo.originalIdentifier };
        result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath);
        if (result.content) {
            return { readmeContent: result.content, actualSourceRepoInfo: gitlabInfo };
        }
        console.warn(`GitLab.com attempt for '${initialRepoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`);
        
        throw new Error(`Could not resolve '${initialRepoInfo.originalIdentifier}' on GitHub or GitLab.com, or ${filePath} not found on any tried branch.`);
    } else { // For direct URLs (github, gitlab, unknown_gitlab_like)
        const result = await tryFetchForProvider(initialRepoInfo, CHECK_BRANCHES_ORDER, filePath);
        if (result.content) {
            return { readmeContent: result.content, actualSourceRepoInfo: initialRepoInfo };
        }
        throw result.error || new Error(`Could not find ${filePath} for '${initialRepoInfo.originalIdentifier}' on any of the branches: ${CHECK_BRANCHES_ORDER.join(', ')}.`);
    }
}

async function generateSite(readmeContent, pageTitle, outputDir, sourceRepoInfo, ogImageUrlCli) { // Changed repoOriginalIdentifier to sourceRepoInfo
    if (isVerbose) console.log(`Generating site for "${pageTitle}" in directory: ${outputDir}`);
    try { await fs.mkdir(outputDir, { recursive: true }); }
    catch (error) { throw new Error(`Failed to create output directory '${outputDir}': ${error.message}`); }

    const htmlContent = marked.parse(readmeContent);

    let ogUrlValue = '';
    // Use originalIdentifier from sourceRepoInfo if it was a full URL.
    // sourceRepoInfo might be null in local mode.
    if (sourceRepoInfo && sourceRepoInfo.originalIdentifier && (sourceRepoInfo.originalIdentifier.startsWith('https://') || sourceRepoInfo.originalIdentifier.startsWith('http://'))) {
        try {
            new URL(sourceRepoInfo.originalIdentifier);
            ogUrlValue = sourceRepoInfo.originalIdentifier;
        } catch (e) {
            console.warn(`Warning: Original identifier '${sourceRepoInfo.originalIdentifier}' is not a valid URL for og:url. Omitting.`);
        }
    }

    let faviconPathInHtml = '';
    let ogImageMetaTagUrl = '';
    try {
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        const sourceDefaultImagePath = path.join(__dirname, 'assets', DEFAULT_IMAGE_FILENAME);
        await fs.access(sourceDefaultImagePath);
        const destDefaultImagePath = path.join(outputDir, DEFAULT_IMAGE_FILENAME);
        await fs.copyFile(sourceDefaultImagePath, destDefaultImagePath);
        faviconPathInHtml = DEFAULT_IMAGE_FILENAME;
        ogImageMetaTagUrl = DEFAULT_IMAGE_FILENAME; // Default OG image
        if (isVerbose) console.log(`Using default image for favicon and as fallback OG image: ${DEFAULT_IMAGE_FILENAME}`);
    } catch (e) {
        console.warn(`Warning: Could not copy or access default image '${DEFAULT_IMAGE_FILENAME}'. Favicon and default OG image may be missing. Error: ${e.message}`);
    }

    if (ogImageUrlCli) {
        ogImageMetaTagUrl = ogImageUrlCli; // Custom URL from --image flag overrides default OG image
        if (isVerbose) console.log(`Using custom image for OG/Twitter previews: ${ogImageUrlCli}`);
    }

    let footerRepoSourceHtml = '';
    if (sourceRepoInfo) { // Only add "from..." if it's a remote repo
        let linkUrl = '';
        let linkText = sourceRepoInfo.repoName; // Default to repoName as link text

        if (sourceRepoInfo.type === 'github') {
            linkUrl = `https://github.com/${sourceRepoInfo.user}/${sourceRepoInfo.repoName}`;
            linkText = `${sourceRepoInfo.user}/${sourceRepoInfo.repoName}`;
        } else if (sourceRepoInfo.type === 'gitlab') {
            linkUrl = `https://gitlab.com/${sourceRepoInfo.userOrGroupPath}/${sourceRepoInfo.repoName}`;
            linkText = `${sourceRepoInfo.userOrGroupPath}/${sourceRepoInfo.repoName}`;
        } else if (sourceRepoInfo.type === 'unknown_gitlab_like') {
            linkUrl = `https://${sourceRepoInfo.host}/${sourceRepoInfo.userOrGroupPath}/${sourceRepoInfo.repoName}`;
            linkText = `${sourceRepoInfo.userOrGroupPath}/${sourceRepoInfo.repoName}@${sourceRepoInfo.host}`;
        }
        // Note: sourceRepoInfo.type will not be 'user_slash_repo' here because fetchReadmeContent resolves it.
        
        if (linkUrl) {
            footerRepoSourceHtml = ` from <a href="${linkUrl}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
        } else if (sourceRepoInfo.originalIdentifier) { // Fallback to original identifier if link couldn't be formed
            footerRepoSourceHtml = ` from ${sourceRepoInfo.originalIdentifier}`;
        }
    }


    const finalHtml = HTML_TEMPLATE
        .replace(/{{PAGE_TITLE}}/g, pageTitle)
        .replace(/{{OG_URL}}/g, ogUrlValue)
        .replace(/{{FAVICON_URL}}/g, faviconPathInHtml)
        .replace(/{{OG_IMAGE_URL}}/g, ogImageMetaTagUrl)
        .replace('{{FOOTER_REPO_SOURCE}}', footerRepoSourceHtml)
        .replace('{{CONTENT}}', htmlContent);

    try { await fs.writeFile(path.join(outputDir, 'index.html'), finalHtml); if (isVerbose) console.log(`Successfully wrote index.html`); }
    catch (error) { throw new Error(`Failed to write index.html: ${error.message}`); }
    try { await fs.writeFile(path.join(outputDir, 'style.css'), CSS_STYLES); if (isVerbose) console.log(`Successfully wrote style.css`); }
    catch (error) { throw new Error(`Failed to write style.css: ${error.message}`); }
}

function isLikelyRepoIdentifier(arg) { return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://'); }

async function main() {
    let rawArgs = process.argv.slice(2);
    // isVerbose is already defined globally
    const verboseFlagIndex = rawArgs.indexOf('--verbose');
    if (verboseFlagIndex !== -1 && process.env.VERBOSE_READMESITE !== 'true') {
         process.env.VERBOSE_READMESITE = 'true';
         rawArgs.splice(verboseFlagIndex, 1);
         if (isVerbose) console.log("Verbose mode enabled.");
    } else if (verboseFlagIndex !== -1) { rawArgs.splice(verboseFlagIndex, 1); }

    let repoIdentifierArg = null;
    let outputDirArg = DEFAULT_OUTPUT_DIR;
    let imageUrlArg = null;
    let localMode = false;
    const localReadmePath = 'README.md';
    
    const imageFlagIndex = rawArgs.indexOf('--image');
    if (imageFlagIndex !== -1) { if (imageFlagIndex + 1 < rawArgs.length && !rawArgs[imageFlagIndex + 1].startsWith('--')) { imageUrlArg = rawArgs[imageFlagIndex + 1]; rawArgs.splice(imageFlagIndex, 2); } else { console.warn("Warning: --image flag provided without a valid URL. Ignoring flag."); rawArgs.splice(imageFlagIndex, 1); } }

    if (rawArgs.length === 0) { localMode = true; }
    else if (rawArgs.length === 1) { if (isLikelyRepoIdentifier(rawArgs[0])) { repoIdentifierArg = rawArgs[0]; } else { localMode = true; outputDirArg = rawArgs[0]; } }
    else { repoIdentifierArg = rawArgs[0]; outputDirArg = rawArgs[1]; }

    if (!localMode && !repoIdentifierArg) {
        console.error("Error: Operation could not be determined. Please provide a repository identifier or run with no identifier for local mode.\n");
        console.log("Usage for remote repository:"); console.log("  readmesite <repository_identifier> [output_directory] [--image <image_url>] [--verbose]\n");
        console.log("Usage for local README.md (in current directory):"); console.log("  readmesite [output_directory] [--image <image_url>] [--verbose]\n");
        console.log("If no arguments are given, it processes ./README.md into ./public.\n");
        console.log("Options:"); console.log("  --image <image_url>      URL for social media preview image."); console.log("  --verbose                Enable verbose logging."); process.exit(1);
    }

    try {
        const resolvedOutputDir = path.resolve(outputDirArg);
        let pageTitle;
        let readmeContent;
        let sourceRepoInfoForFooter = null; // This will hold the info for the footer link
        let ogUrlSource = null; // This will be the original identifier if it was a URL, for og:url

        if (localMode) {
            console.log(`Processing local '${localReadmePath}' -> '${resolvedOutputDir}'`);
            try {
                readmeContent = await fs.readFile(localReadmePath, 'utf-8');
            } catch (readError) { if (readError.code === 'ENOENT') { throw new Error(`Local mode error: '${localReadmePath}' not found in the current directory.`); } throw new Error(`Local mode error: Could not read '${localReadmePath}': ${readError.message}`); }
            
            pageTitle = extractFirstH1(readmeContent);
            if (!pageTitle) { try { const pkgJsonPath = path.join(process.cwd(), 'package.json'); const pkgJsonContent = await fs.readFile(pkgJsonPath, 'utf-8'); const pkgJson = JSON.parse(pkgJsonContent); if (pkgJson && pkgJson.name) pageTitle = pkgJson.name; } catch (e) { /* ignore */ } }
            if (!pageTitle) pageTitle = path.basename(process.cwd());
            if (isVerbose) console.log(`Determined page title: "${pageTitle}"`);
            // sourceRepoInfoForFooter remains null for local mode, so no "from..." in footer.
            // ogUrlSource remains null for local mode.

        } else { // Remote mode
            const initialRepoInfo = await parseRepoIdentifier(repoIdentifierArg);
            ogUrlSource = initialRepoInfo.originalIdentifier; // Used for og:url if it's a full URL
            
            let logIdentifier = initialRepoInfo.originalIdentifier;
            if (initialRepoInfo.type === 'user_slash_repo') { logIdentifier = `${initialRepoInfo.user}/${initialRepoInfo.repoName}`; }
            console.log(`Processing remote repository '${logIdentifier}' -> '${resolvedOutputDir}'`);
            
            const fetchResult = await fetchReadmeContent(initialRepoInfo);
            readmeContent = fetchResult.readmeContent;
            sourceRepoInfoForFooter = fetchResult.actualSourceRepoInfo; // Used for footer link

            if (isVerbose) console.log(`README.md fetched successfully from ${sourceRepoInfoForFooter.host || 'resolved provider'}.`);

            pageTitle = extractFirstH1(readmeContent) || sourceRepoInfoForFooter.repoName; // Fallback to resolved repoName
            if (isVerbose) console.log(`Determined page title: "${pageTitle}"`);
        }
        
        if (isVerbose && imageUrlArg) console.log(`Custom image for social previews: ${imageUrlArg}`);
        await generateSite(readmeContent, pageTitle, resolvedOutputDir, sourceRepoInfoForFooter, imageUrlArg); // Pass sourceRepoInfoForFooter

        console.log(`\n✅ Site generation complete!`);
        console.log(`Static site files are located in: ${resolvedOutputDir}`);

        if (!process.env.CI) {
            console.log("\n🚀 To deploy (example for Cloudflare Pages):");
            console.log("   If building locally, you can push the output directory or use Wrangler.");
            console.log("   If building on Cloudflare Pages, your build command could be as simple as: npx readmesite");
        }
    } catch (error) {
        console.error(`\n❌ Error: ${error.message}`);
        if (error.cause) { console.error(`Cause: ${error.cause}`); }
        process.exit(1);
    }
}

main();
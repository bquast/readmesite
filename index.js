#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';

const DEFAULT_OUTPUT_DIR = 'public';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];

const HTML_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TITLE}}</title>

    <meta property="og:type" content="website">
    <meta property="og:url" content="{{OG_URL}}">
    <meta property="og:title" content="{{PAGE_TITLE}}">
    <meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta property="og:site_name" content="{{PAGE_TITLE}}">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="{{OG_URL}}">
    <meta name="twitter:title" content="{{PAGE_TITLE}}">
    <meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“–</text></svg>">
</head>
<body>
    <main class="container">
        {{CONTENT}}
    </main>
    <footer>
        <p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a></p>
    </footer>
</body>
</html>`;

const CSS_STYLES = `
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    line-height: 1.6;
    color: #24292e;
    margin: 0;
    padding: 0;
    background-color: #f6f8fa;
}
/* ... (rest of CSS styles remain the same as previous version) ... */
.container {
    max-width: 800px;
    margin: 30px auto;
    padding: 20px 40px;
    background-color: #ffffff;
    border: 1px solid #d1d5da;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
    border-bottom: 1px solid #eaecef;
    padding-bottom: .3em;
}
h1 { font-size: 2em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1em; }
h5 { font-size: .875em; }
h6 { font-size: .85em; color: #6a737d; }
p { margin-top: 0; margin-bottom: 16px; }
ul, ol { margin-top: 0; margin-bottom: 16px; padding-left: 2em; }
a { color: #0366d6; text-decoration: none; }
a:hover { text-decoration: underline; }
code {
    font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    background-color: rgba(27,31,35,.05);
    border-radius: 3px;
    padding: .2em .4em;
    margin: 0;
}
pre {
    font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f6f8fa;
    border-radius: 3px;
    padding: 16px;
    overflow: auto;
    margin-bottom: 16px;
}
pre code {
    font-size: 100%; padding: 0; margin: 0; background-color: transparent; border: 0;
    display: inline; max-width: auto; overflow: visible; line-height: inherit; word-wrap: normal;
}
img { max-width: 100%; height: auto; box-sizing: border-box; margin-top: 16px; margin-bottom: 16px; }
blockquote { margin: 0 0 16px 0; padding: 0 1em; color: #6a737d; border-left: .25em solid #dfe2e5; }
table { border-collapse: collapse; margin-bottom: 16px; width: 100%; display: block; overflow: auto; }
th, td { border: 1px solid #dfe2e5; padding: 6px 13px; }
tr { background-color: #fff; border-top: 1px solid #c6cbd1; }
tr:nth-child(2n) { background-color: #f6f8fa; }
hr { height: .25em; padding: 0; margin: 24px 0; background-color: #e1e4e8; border: 0; }
footer {
    text-align: center; margin-top: 40px; padding-top: 20px;
    border-top: 1px solid #eaecef; font-size: 0.9em; color: #586069;
}
footer a { color: #0366d6; }
`;

async function parseRepoIdentifier(identifier) {
    // ... (parseRepoIdentifier remains the same as previous version)
    if (!identifier) {
        throw new Error("Repository identifier argument is missing.");
    }
    try {
        const url = new URL(identifier); 
        const hostname = url.hostname.toLowerCase();
        const pathParts = url.pathname.split('/').filter(Boolean);
        if (pathParts.length < 2) {
             throw new Error(`URL path does not seem to contain enough segments for a repository: ${url.pathname}`);
        }
        if (hostname === 'github.com') {
            return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1], originalIdentifier: identifier };
        } else if (hostname === 'gitlab.com') {
            const repoName = pathParts[pathParts.length - 1];
            const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/');
            return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier };
        } else if (url.protocol === 'https:') {
            const repoName = pathParts[pathParts.length - 1];
            const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/');
            console.warn(`Processing unknown host '${hostname}' using GitLab-like URL pattern for raw files.`);
            return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier };
        }
    } catch (e) {
        if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) {
             console.warn(`URL parsing attempt failed for '${identifier}': ${e.message}. Will try as 'user/repo'.`);
        }
    }
    if (identifier.includes('://')) {
        throw new Error(`Invalid repository identifier: '${identifier}'. Full URLs must be valid. For 'user/repo' shorthand, do not include protocol.`);
    }
    const parts = identifier.split('/');
    if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) {
        return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier };
    }
    throw new Error(`Could not parse repository identifier: '${identifier}'. Please use 'username/repository' format or a full HTTPS URL.`);
}

async function tryFetchForProvider(providerRepoInfo, branches, filePath) {
    // ... (tryFetchForProvider remains the same as previous version)
    let lastBranchError = null;
    for (const branch of branches) {
        let readmeUrl;
        const repoDisplayPath = providerRepoInfo.type === 'github' ? `<span class="math-inline">\{providerRepoInfo\.user\}/</span>{providerRepoInfo.repoName}` : `<span class="math-inline">\{providerRepoInfo\.userOrGroupPath\}/</span>{providerRepoInfo.repoName}`;
        if (providerRepoInfo.type === 'github') {
            readmeUrl = `https://raw.githubusercontent.com/<span class="math-inline">\{providerRepoInfo\.user\}/</span>{providerRepoInfo.repoName}/<span class="math-inline">\{branch\}/</span>{filePath}`;
        } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') {
            readmeUrl = `https://<span class="math-inline">\{providerRepoInfo\.host\}/</span>{providerRepoInfo.userOrGroupPath}/<span class="math-inline">\{providerRepoInfo\.repoName\}/\-/raw/</span>{branch}/${filePath}`;
        } else {
            return { content: null, error: new Error(`Internal error: Unsupported provider type: ${providerRepoInfo.type}`) };
        }
        console.log(`Attempting: ${readmeUrl}`);
        try {
            const response = await fetch(readmeUrl);
            if (response.ok) {
                return { content: await response.text(), error: null };
            }
            if (response.status === 404) {
                lastBranchError = new Error(`<span class="math-inline">\{filePath\} not found on branch '</span>{branch}' for ${repoDisplayPath} at ${providerRepoInfo.host}`);
                console.warn(lastBranchError.message); 
            } else {
                throw new Error(`Failed to fetch ${filePath} from ${readmeUrl}. Status: ${response.status} ${response.statusText}`);
            }
        } catch (fetchError) { 
            lastBranchError = new Error(`Network/fetch error for ${readmeUrl}: ${fetchError.message}`);
            console.warn(lastBranchError.message);
            return { content: null, error: lastBranchError }; 
        }
    }
    return { content: null, error: lastBranchError || new Error(`${filePath} not found on any attempted branch for ${repoDisplayPath} at ${providerRepoInfo.host}.`) };
}

async function fetchReadmeContent(repoInfo) {
    // ... (fetchReadmeContent remains the same as previous version)
    const filePath = 'README.md';
    if (repoInfo.type === 'user_slash_repo') {
        console.log(`Input '${repoInfo.originalIdentifier}' is 'username/repository' shorthand.`);
        console.log("Attempting to resolve on GitHub (github.com)...");
        const githubInfo = {
            type: 'github', host: 'github.com', user: repoInfo.user, repoName: repoInfo.repoName,
            originalIdentifier: repoInfo.originalIdentifier
        };
        let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath);
        if (result.content) return result.content;
        console.warn(`GitHub attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`);

        console.log("Attempting to resolve on GitLab (gitlab.com)...");
        const gitlabInfo = {
            type: 'gitlab', host: 'gitlab.com', userOrGroupPath: repoInfo.user, repoName: repoInfo.repoName,
            originalIdentifier: repoInfo.originalIdentifier
        };
        result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath);
        if (result.content) return result.content;
        console.warn(`GitLab.com attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`);
        
        throw new Error(`Could not resolve '${repoInfo.originalIdentifier}' on GitHub or GitLab.com, or ${filePath} not found on any tried branch.`);
    } else {
        const result = await tryFetchForProvider(repoInfo, CHECK_BRANCHES_ORDER, filePath);
        if (result.content) return result.content;
        throw result.error || new Error(`Could not find <span class="math-inline">\{filePath\} for '</span>{repoInfo.originalIdentifier}' on any of the branches: ${CHECK_BRANCHES_ORDER.join(', ')}.`);
    }
}

async function generateSite(readmeContent, pageTitleBase, outputDir, repoOriginalIdentifier) { // Added repoOriginalIdentifier
    console.log(`Generating site in directory: ${outputDir}`);
    try {
        await fs.mkdir(outputDir, { recursive: true });
    } catch (error) {
        throw new Error(`Failed to create output directory '${outputDir}': ${error.message}`);
    }

    const htmlContent = marked.parse(readmeContent);
    const sitePageTitle = pageTitleBase; // This is repoInfo.repoName

    let ogUrlValue = '';
    // Use the original identifier if it's a full, valid URL for og:url
    if (repoOriginalIdentifier && (repoOriginalIdentifier.startsWith('https://') || repoOriginalIdentifier.startsWith('http://'))) {
        try {
            new URL(repoOriginalIdentifier); // Validate if it's a proper URL
            ogUrlValue = repoOriginalIdentifier;
        } catch (e) {
            // Not a valid URL, leave ogUrlValue empty or use a fallback
            console.warn(`Original identifier '${repoOriginalIdentifier}' is not a valid URL for og:url. Omitting.`);
        }
    }
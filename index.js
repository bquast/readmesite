#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import { fileURLToPath } from 'url';

const DEFAULT_OUTPUT_DIR = 'public';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_FILENAME = 'readmesite-og-default.png';

const isVerbose = process.argv.includes('--verbose'); // Check for verbose flag early

const HTML_TEMPLATE = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>{{PAGE_TITLE}}</title><meta property="og:type" content="website"><meta property="og:url" content="{{OG_URL}}"><meta property="og:title" content="{{PAGE_TITLE}}"><meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository."><meta property="og:image" content="{{OG_IMAGE_URL}}"><meta property="og:site_name" content="{{PAGE_TITLE}}"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:url" content="{{OG_URL}}"><meta name="twitter:title" content="{{PAGE_TITLE}}"><meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository."><meta name="twitter:image" content="{{OG_IMAGE_URL}}"><link rel="stylesheet" href="style.css"><link rel="icon" href="{{FAVICON_URL}}" type="image/png"></head><body><main class="container">{{CONTENT}}</main><footer><p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a></p></footer></body></html>`;
const CSS_STYLES = `body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;} .container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);} h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;} h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;} p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;} a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;} code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;} pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;} pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;} img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;} blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;} table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;} th,td {border:1px solid #dfe2e5; padding:6px 13px;} tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;} hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;} footer {text-align:center; margin-top:40px; padding-top:20px; border-top:1px solid #eaecef; font-size:.9em; color:#586069;} footer a {color:#0366d6;}`;

// Helper function to extract plain text from inline tokens (used for H1)
function getPlainTextFromInlineTokens(inlineTokens) {
    return inlineTokens.map(token => {
        if (token.type === 'text' || token.type === 'codespan') {
            return token.raw || token.text; // Prefer raw to avoid potential double-escaping
        }
        if (token.tokens && token.tokens.length > 0) { // For em, strong, link, etc.
            return getPlainTextFromInlineTokens(token.tokens);
        }
        return token.raw || token.text || ''; // Fallback for other simple inline tokens
    }).join('');
}

// Helper function to extract the first H1 content as plain text
function extractFirstH1(markdownContent) {
    if (!markdownContent) return null;
    try {
        const tokens = marked.lexer(markdownContent);
        const firstH1Token = tokens.find(token => token.type === 'heading' && token.depth === 1);
        if (firstH1Token && firstH1Token.tokens) { // tokens property holds inline content
            let title = getPlainTextFromInlineTokens(firstH1Token.tokens).trim();
            // Basic HTML entity decoding that might occur if raw was used and entities were present
            title = title.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#039;/g, "'");
            return title || null; // Return null if title ends up empty
        }
    } catch (e) {
        if (isVerbose) console.warn(`Warning: Could not extract H1 title from README: ${e.message}`);
    }
    return null;
}

async function parseRepoIdentifier(identifier) { /* ... (same as previous complete version) ... */ if (!identifier) { throw new Error("Repository identifier argument is missing."); } try { const url = new URL(identifier); const hostname = url.hostname.toLowerCase(); const pathParts = url.pathname.split('/').filter(Boolean); if (pathParts.length < 2) { throw new Error(`URL path does not seem to contain enough segments for a repository: ${url.pathname}`); } if (hostname === 'github.com') { return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1], originalIdentifier: identifier }; } else if (hostname === 'gitlab.com') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } else if (url.protocol === 'https:') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); if (isVerbose) console.log(`Info: Processing unknown host '${hostname}' using GitLab-like URL pattern.`); return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } } catch (e) { if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) { if (isVerbose) console.warn(`URL parsing attempt failed for '${identifier}': ${e.message}. Will try as 'user/repo'.`); } } if (identifier.includes('://')) { throw new Error(`Invalid repository identifier: '${identifier}'. Full URLs must be valid. For 'user/repo' shorthand, do not include protocol.`); } const parts = identifier.split('/'); if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) { return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier }; } throw new Error(`Could not parse repository identifier: '${identifier}'. Please use 'username/repository' format or a full HTTPS URL.`); }
async function tryFetchForProvider(providerRepoInfo, branches, filePath) { /* ... (same as previous complete version, uses 'isVerbose' internally) ... */ let lastBranchError = null; for (const branch of branches) { let readmeUrl; const repoDisplayPath = providerRepoInfo.type === 'github' ? `${providerRepoInfo.user}/${providerRepoInfo.repoName}` : `${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`; if (providerRepoInfo.type === 'github') { readmeUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`; } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') { readmeUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`; } else { return { content: null, error: new Error(`Internal error: Unsupported provider type: ${providerRepoInfo.type}`) }; } if (isVerbose) console.log(`Attempting: ${readmeUrl}`); try { const response = await fetch(readmeUrl); if (response.ok) { return { content: await response.text(), error: null }; } if (response.status === 404) { lastBranchError = new Error(`${filePath} not found on branch '${branch}' for ${repoDisplayPath} at ${providerRepoInfo.host}`); if (isVerbose) console.warn(lastBranchError.message); } else { throw new Error(`Failed to fetch ${filePath} from ${readmeUrl}. Status: ${response.status} ${response.statusText}`); } } catch (fetchError) { lastBranchError = new Error(`Network/fetch error for ${readmeUrl}: ${fetchError.message}`); console.warn(lastBranchError.message); return { content: null, error: lastBranchError }; } } return { content: null, error: lastBranchError || new Error(`${filePath} not found on any attempted branch for ${repoDisplayPath} at ${providerRepoInfo.host}.`) }; }
async function fetchReadmeContent(repoInfo) { /* ... (same as previous complete version, uses 'isVerbose' internally) ... */ const filePath = 'README.md'; if (repoInfo.type === 'user_slash_repo') { if (isVerbose) console.log(`Input '${repoInfo.originalIdentifier}' is 'username/repository' shorthand.`); if (isVerbose) console.log("Attempting to resolve on GitHub (github.com)..."); const githubInfo = { type: 'github', host: 'github.com', user: repoInfo.user, repoName: repoInfo.repoName, originalIdentifier: repoInfo.originalIdentifier }; let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; console.warn(`GitHub attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); if (isVerbose) console.log("Attempting to resolve on GitLab (gitlab.com)..."); const gitlabInfo = { type: 'gitlab', host: 'gitlab.com', userOrGroupPath: repoInfo.user, repoName: repoInfo.repoName, originalIdentifier: repoInfo.originalIdentifier }; result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; console.warn(`GitLab.com attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); throw new Error(`Could not resolve '${repoInfo.originalIdentifier}' on GitHub or GitLab.com, or ${filePath} not found on any tried branch.`); } else { const result = await tryFetchForProvider(repoInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; throw result.error || new Error(`Could not find ${filePath} for '${repoInfo.originalIdentifier}' on any of the branches: ${CHECK_BRANCHES_ORDER.join(', ')}.`); } }
async function generateSite(readmeContent, pageTitle, outputDir, repoOriginalIdentifier, ogImageUrlCli) { // Renamed pageTitleBase to pageTitle
    if (isVerbose) console.log(`Generating site for "${pageTitle}" in directory: ${outputDir}`);
    try { await fs.mkdir(outputDir, { recursive: true }); }
    catch (error) { throw new Error(`Failed to create output directory '${outputDir}': ${error.message}`); }

    const htmlContent = marked.parse(readmeContent);
    // pageTitle is now passed in directly after H1 extraction or fallback logic

    let ogUrlValue = '';
    if (repoOriginalIdentifier && (repoOriginalIdentifier.startsWith('https://') || repoOriginalIdentifier.startsWith('http://'))) {
        try { new URL(repoOriginalIdentifier); ogUrlValue = repoOriginalIdentifier; }
        catch (e) { console.warn(`Warning: Original identifier '${repoOriginalIdentifier}' is not a valid URL for og:url. Omitting.`); }
    }

    let faviconPathInHtml = '';
    let ogImageMetaTagUrl = '';
    try {
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        const sourceDefaultImagePath = path.join(__dirname, 'assets', DEFAULT_IMAGE_FILENAME);
        await fs.access(sourceDefaultImagePath);
        const destDefaultImagePath = path.join(outputDir, DEFAULT_IMAGE_FILENAME);
        await fs.copyFile(sourceDefaultImagePath, destDefaultImagePath);
        faviconPathInHtml = DEFAULT_IMAGE_FILENAME;
        ogImageMetaTagUrl = DEFAULT_IMAGE_FILENAME;
        if (isVerbose) console.log(`Using default image for favicon and as fallback OG image: ${DEFAULT_IMAGE_FILENAME}`);
    } catch (e) {
        console.warn(`Warning: Could not copy or access default image '${DEFAULT_IMAGE_FILENAME}'. Favicon and default OG image may be missing. Error: ${e.message}`);
    }

    if (ogImageUrlCli) {
        ogImageMetaTagUrl = ogImageUrlCli;
        if (isVerbose) console.log(`Using custom image for OG/Twitter previews: ${ogImageUrlCli}`);
    }

    const finalHtml = HTML_TEMPLATE
        .replace(/{{PAGE_TITLE}}/g, pageTitle)
        .replace(/{{OG_URL}}/g, ogUrlValue)
        .replace(/{{FAVICON_URL}}/g, faviconPathInHtml)
        .replace(/{{OG_IMAGE_URL}}/g, ogImageMetaTagUrl)
        .replace('{{CONTENT}}', htmlContent);

    try { await fs.writeFile(path.join(outputDir, 'index.html'), finalHtml); if (isVerbose) console.log(`Successfully wrote index.html`); }
    catch (error) { throw new Error(`Failed to write index.html: ${error.message}`); }
    try { await fs.writeFile(path.join(outputDir, 'style.css'), CSS_STYLES); if (isVerbose) console.log(`Successfully wrote style.css`); }
    catch (error) { throw new Error(`Failed to write style.css: ${error.message}`); }
}

function isLikelyRepoIdentifier(arg) { return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://'); }

async function main() {
    let rawArgs = process.argv.slice(2);
    // isVerbose is already defined globally based on initial argv check
    const verboseFlagIndex = rawArgs.indexOf('--verbose'); // Find it again to remove it if it was not the first one
    if (verboseFlagIndex !== -1 && process.env.VERBOSE_READMESITE !== 'true') { // If not already set (e.g. by global const)
         process.env.VERBOSE_READMESITE = 'true'; // Set env var if --verbose is present
         rawArgs.splice(verboseFlagIndex, 1);
         if (isVerbose) console.log("Verbose mode enabled.");
    } else if (verboseFlagIndex !== -1) { // Already set, just remove
        rawArgs.splice(verboseFlagIndex, 1);
    }


    let repoIdentifierArg = null;
    let outputDirArg = DEFAULT_OUTPUT_DIR;
    let imageUrlArg = null;
    let localMode = false;
    const localReadmePath = 'README.md';
    
    const imageFlagIndex = rawArgs.indexOf('--image');
    if (imageFlagIndex !== -1) { if (imageFlagIndex + 1 < rawArgs.length && !rawArgs[imageFlagIndex + 1].startsWith('--')) { imageUrlArg = rawArgs[imageFlagIndex + 1]; rawArgs.splice(imageFlagIndex, 2); } else { console.warn("Warning: --image flag provided without a valid URL. Ignoring flag."); rawArgs.splice(imageFlagIndex, 1); } }

    if (rawArgs.length === 0) { localMode = true; }
    else if (rawArgs.length === 1) { if (isLikelyRepoIdentifier(rawArgs[0])) { repoIdentifierArg = rawArgs[0]; } else { localMode = true; outputDirArg = rawArgs[0]; } }
    else { repoIdentifierArg = rawArgs[0]; outputDirArg = rawArgs[1]; }

    if (!localMode && !repoIdentifierArg) {
        console.error("Error: Operation could not be determined. Please provide a repository identifier or run with no identifier for local mode.\n");
        console.log("Usage for remote repository:"); console.log("  readmesite <repository_identifier> [output_directory] [--image <image_url>] [--verbose]\n");
        console.log("Usage for local README.md (in current directory):"); console.log("  readmesite [output_directory] [--image <image_url>] [--verbose]\n");
        console.log("If no arguments are given, it processes ./README.md into ./public.\n");
        console.log("Options:"); console.log("  --image <image_url>      URL for social media preview image."); console.log("  --verbose                Enable verbose logging."); process.exit(1);
    }

    try {
        const resolvedOutputDir = path.resolve(outputDirArg);
        let pageTitle;
        let readmeContent;
        let originalIdentifierForOg = null;

        if (localMode) {
            console.log(`Processing local '${localReadmePath}' -> '${resolvedOutputDir}'`);
            try {
                readmeContent = await fs.readFile(localReadmePath, 'utf-8');
            } catch (readError) { if (readError.code === 'ENOENT') { throw new Error(`Local mode error: '${localReadmePath}' not found in the current directory.`); } throw new Error(`Local mode error: Could not read '${localReadmePath}': ${readError.message}`); }
            
            pageTitle = extractFirstH1(readmeContent);
            if (!pageTitle) {
                try {
                    const pkgJsonPath = path.join(process.cwd(), 'package.json');
                    const pkgJsonContent = await fs.readFile(pkgJsonPath, 'utf-8');
                    const pkgJson = JSON.parse(pkgJsonContent);
                    if (pkgJson && pkgJson.name) pageTitle = pkgJson.name;
                } catch (e) { /* ignore if no package.json or no name */ }
            }
            if (!pageTitle) pageTitle = path.basename(process.cwd()); // Final fallback
            if (isVerbose) console.log(`Determined page title: "${pageTitle}"`);
            // originalIdentifierForOg remains null for local mode, leading to empty og:url

        } else { // Remote mode
            const repoInfo = await parseRepoIdentifier(repoIdentifierArg);
            originalIdentifierForOg = repoInfo.originalIdentifier; // For og:url
            let logIdentifier = repoInfo.originalIdentifier;
            if (repoInfo.type === 'user_slash_repo') { logIdentifier = `${repoInfo.user}/${repoInfo.repoName}`; }
            
            console.log(`Processing remote repository '${logIdentifier}' -> '${resolvedOutputDir}'`);
            
            readmeContent = await fetchReadmeContent(repoInfo);
            if (isVerbose) console.log("README.md fetched successfully.");

            pageTitle = extractFirstH1(readmeContent);
            if (!pageTitle) pageTitle = repoInfo.repoName; // Fallback to repoName
            if (isVerbose) console.log(`Determined page title: "${pageTitle}"`);
        }
        
        if (isVerbose && imageUrlArg) console.log(`Custom image for social previews: ${imageUrlArg}`);
        await generateSite(readmeContent, pageTitle, resolvedOutputDir, originalIdentifierForOg, imageUrlArg);

        console.log(`\n✅ Site generation complete!`);
        console.log(`Static site files are located in: ${resolvedOutputDir}`);

        if (!process.env.CI) {
            console.log("\n🚀 To deploy (example for Cloudflare Pages):");
            console.log("   If building locally, you can push the output directory or use Wrangler.");
            console.log("   If building on Cloudflare Pages, your build command could be as simple as: npx readmesite");
        }
    } catch (error) {
        console.error(`\n❌ Error: ${error.message}`);
        if (error.cause) { console.error(`Cause: ${error.cause}`); }
        process.exit(1);
    }
}

main();
#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import { fileURLToPath } from 'url';

const DEFAULT_OUTPUT_DIR = '.';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_FILENAME = 'readmesite-og-default.png';
const THEME_STORE_BASE_URL = 'https://store.readme.site/themes';
const LOCAL_THEMES_DIR = '.';

const initialArgsForVerbose = process.argv.slice(2);
const verboseArgIndexForIsVerbose = initialArgsForVerbose.indexOf('--verbose');
const isVerbose = verboseArgIndexForIsVerbose !== -1;
if (isVerbose) {
    process.env.VERBOSE_READMESITE = 'true';
}

const HTML_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{PAGE_TITLE}}</title>
    {{GOOGLE_ANALYTICS_SCRIPT}}
    <meta property="og:type" content="website">
    <meta property="og:url" content="{{OG_URL}}">
    <meta property="og:title" content="{{PAGE_TITLE}}">
    <meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta property="og:image" content="{{OG_IMAGE_URL}}">
    <meta property="og:site_name" content="{{PAGE_TITLE}}">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="{{OG_URL}}">
    <meta name="twitter:title" content="{{PAGE_TITLE}}">
    <meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository.">
    <meta name="twitter:image" content="{{OG_IMAGE_URL}}">
    <link rel="stylesheet" href="style.css" id="readmesite-theme-stylesheet">
    <link rel="icon" href="{{FAVICON_URL}}" type="image/png">
</head>
<body>
    <main class="container">
        {{CONTENT}}
        <hr class="readmesite-footer-separator">
        <div class="readmesite-footer">
            <p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a>{{FOOTER_REPO_SOURCE_HTML}}</p>
        </div>
    </main>
    {{BROWSER_CONSOLE_LOG_SCRIPT}}
</body>
</html>`;

const CSS_STYLES = `body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;} .container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);} h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;} h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;} p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;} a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;} code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;} pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;} pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;} img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;} blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;} table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;} th,td {border:1px solid #dfe2e5; padding:6px 13px;} tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;} hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;} hr.readmesite-footer-separator {height: 2px; background-color: #d1d5da; border: none; margin-top: 48px; margin-bottom: 24px;} div.readmesite-footer {text-align: center; font-size: 0.85em; color: #586069; padding-bottom: 10px; margin-top: 0;} div.readmesite-footer p { margin: 0; } div.readmesite-footer a {color: #0366d6; text-decoration: none;} div.readmesite-footer a:hover {text-decoration: underline;}`;

function sanitizeUrlForPublicDisplay(urlString) {
    if (!urlString || typeof urlString !== 'string' || (!urlString.startsWith('http:') && !urlString.startsWith('https://'))) {
        return urlString;
    }
    try {
        const urlObj = new URL(urlString);
        return `${urlObj.protocol}//${urlObj.hostname}${urlObj.port ? ':' + urlObj.port : ''}${urlObj.pathname}${urlObj.search}${urlObj.hash}`;
    } catch (e) {
        if (isVerbose) console.warn(`Warning: Could not sanitize URL '${urlString}': ${e.message}`);
        return urlString;
    }
}

function getPlainTextFromInlineTokens(inlineTokens) { return inlineTokens.map(token => { if (token.type === 'text' || token.type === 'codespan') { return token.raw || token.text; } if (token.tokens && token.tokens.length > 0) { return getPlainTextFromInlineTokens(token.tokens); } return token.raw || token.text || ''; }).join(''); }
function extractFirstH1(markdownContent) { if (!markdownContent) return null; try { const tokens = marked.lexer(markdownContent); const firstH1Token = tokens.find(token => token.type === 'heading' && token.depth === 1); if (firstH1Token && firstH1Token.tokens) { let title = getPlainTextFromInlineTokens(firstH1Token.tokens).trim(); title = title.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#039;/g, "'"); return title || null; } } catch (e) { if (isVerbose) console.warn(`Warning: Could not extract H1 title from README: ${e.message}`); } return null; }
async function parseRepoIdentifier(identifier) { if (!identifier) { throw new Error("Repository identifier argument is missing."); } try { const url = new URL(identifier); const hostname = url.hostname.toLowerCase(); const pathParts = url.pathname.split('/').filter(Boolean); if (pathParts.length < 2) { throw new Error(`URL path does not seem to contain enough segments for a repository: ${url.pathname}`); } if (hostname === 'github.com') { return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1], originalIdentifier: identifier }; } else if (hostname === 'gitlab.com') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } else if (url.protocol === 'https:') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); if (isVerbose) console.log(`Info: Processing unknown host '${hostname}' using GitLab-like URL pattern.`); return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } } catch (e) { if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) { if (isVerbose) console.warn(`URL parsing attempt failed for '${identifier}': ${e.message}. Will try as 'user/repo'.`); } } if (identifier.includes('://')) { throw new Error(`Invalid repository identifier: '${identifier}'. Full URLs must be valid. For 'user/repo' shorthand, do not include protocol.`); } const parts = identifier.split('/'); if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) { return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier }; } throw new Error(`Could not parse repository identifier: '${identifier}'. Please use 'username/repository' format or a full HTTPS URL.`); }
async function tryFetchForProvider(providerRepoInfo, branches, filePath) { let lastBranchError = null; for (const branch of branches) { let readmeUrl; const repoDisplayPath = providerRepoInfo.type === 'github' ? `${providerRepoInfo.user}/${providerRepoInfo.repoName}` : `${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`; if (providerRepoInfo.type === 'github') { readmeUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`; } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') { readmeUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`; } else { return { content: null, error: new Error(`Internal error: Unsupported provider type: ${providerRepoInfo.type}`) }; } if (isVerbose) console.log(`Attempting: ${readmeUrl}`); try { const response = await fetch(readmeUrl); if (response.ok) { return { content: await response.text(), error: null }; } if (response.status === 404) { lastBranchError = new Error(`${filePath} not found on branch '${branch}' for ${repoDisplayPath} at ${providerRepoInfo.host}`); if (isVerbose) console.warn(lastBranchError.message); } else { throw new Error(`Failed to fetch ${filePath} from ${readmeUrl}. Status: ${response.status} ${response.statusText}`); } } catch (fetchError) { lastBranchError = new Error(`Network/fetch error for ${readmeUrl}: ${fetchError.message}`); console.warn(lastBranchError.message); return { content: null, error: lastBranchError }; } } return { content: null, error: lastBranchError || new Error(`${filePath} not found on any attempted branch for ${repoDisplayPath} at ${providerRepoInfo.host}.`) }; }
async function fetchReadmeContent(initialRepoInfo) { const filePath = 'README.md'; if (initialRepoInfo.type === 'user_slash_repo') { if (isVerbose) console.log(`Input '${initialRepoInfo.originalIdentifier}' is 'username/repository' shorthand.`); if (isVerbose) console.log("Attempting to resolve on GitHub (github.com)..."); const githubInfo = { type: 'github', host: 'github.com', user: initialRepoInfo.user, repoName: initialRepoInfo.repoName, originalIdentifier: initialRepoInfo.originalIdentifier }; let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) { return { readmeContent: result.content, actualSourceRepoInfo: githubInfo }; } console.warn(`GitHub attempt for '${initialRepoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); if (isVerbose) console.log("Attempting to resolve on GitLab (gitlab.com)..."); const gitlabInfo = { type: 'gitlab', host: 'gitlab.com', userOrGroupPath: initialRepoInfo.user, repoName: initialRepoInfo.repoName, originalIdentifier: initialRepoInfo.originalIdentifier }; result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) { return { readmeContent: result.content, actualSourceRepoInfo: gitlabInfo }; } console.warn(`GitLab.com attempt for '${initialRepoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); throw new Error(`Could not resolve '${initialRepoInfo.originalIdentifier}' on GitHub or GitLab.com, or ${filePath} not found on any tried branch.`); } else { const result = await tryFetchForProvider(initialRepoInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) { return { readmeContent: result.content, actualSourceRepoInfo: initialRepoInfo }; } throw result.error || new Error(`Could not find ${filePath} for '${initialRepoInfo.originalIdentifier}' on any of the branches: ${CHECK_BRANCHES_ORDER.join(', ')}.`); } }
async function getLocalGitRepoInfo() { try { const gitConfigPath = path.join(process.cwd(), '.git', 'config'); const configContent = await fs.readFile(gitConfigPath, 'utf-8'); const originUrlMatch = configContent.match(/\[remote\s+"origin"\]\s*[^\[]*?\s*url\s*=\s*([^\s]+)/); if (originUrlMatch && originUrlMatch[1]) { let url = originUrlMatch[1]; url = url.replace(/^git@([^:]+):(.+?)(\.git)?$/, 'https://$1/$2'); if (url.endsWith('.git')) url = url.substring(0, url.length - 4); if (url.startsWith('http://')) url = 'https://' + url.substring(7); if (!url.startsWith('https://')) { if (isVerbose) console.log(`Info: Non-standard remote URL found in .git/config: ${originUrlMatch[1]}`); return null; } let displayName = url; try { const parsedUrl = new URL(url); const pathParts = parsedUrl.pathname.split('/').filter(Boolean); if (pathParts.length >= 2) displayName = `${pathParts[pathParts.length - 2]}/${pathParts[pathParts.length - 1]}`; else if (pathParts.length === 1) displayName = pathParts[0]; } catch (e) { /* Use full URL as displayName if parsing path fails */ } return { url: url, name: displayName }; } } catch (e) { if (isVerbose) console.log(`Info: Could not determine local git repository URL from .git/config. (${e.message})`); } return null; }

async function fetchOrReadContent(pathOrUrl, isThemeAsset = false) {
    if (!pathOrUrl) return null;
    const isFileUrl = pathOrUrl.startsWith('file://');
    const isHttpUrl = pathOrUrl.startsWith('http:') || pathOrUrl.startsWith('https://');
    const isUrlProtocol = isFileUrl || isHttpUrl;

    if (isVerbose) console.log(`Getting content from ${isUrlProtocol ? 'URL' : 'path'}: ${pathOrUrl}`);
    try {
        if (isHttpUrl) {
            const response = await fetch(pathOrUrl);
            if (!response.ok) {
                if (isThemeAsset && response.status === 404) {
                    if (isVerbose) console.warn(`Theme asset not found at URL: ${pathOrUrl}`);
                    return null;
                }
                throw new Error(`Failed to fetch ${pathOrUrl}. Status: ${response.status} ${response.statusText}`);
            }
            return await response.text();
        } else { // Read local file (could be absolute path or relative, or file:// URL)
            let filePathToRead = pathOrUrl;
            if (isFileUrl) {
                filePathToRead = fileURLToPath(pathOrUrl);
            }
            return await fs.readFile(filePathToRead, 'utf-8');
        }
    } catch (e) {
        if (isThemeAsset) {
            if (isVerbose) console.warn(`Could not fetch or read theme asset from '${pathOrUrl}': ${e.message}`);
            return null;
        }
        throw new Error(`Could not fetch or read content from '${pathOrUrl}': ${e.message}`);
    }
}


async function generateSite(readmeContent, pageTitle, outputDir, ogUrlToUse, ogImageUrlCli, footerLinkHref, footerLinkText, gaPropertyId,
                            customCssContent, customHtmlTemplate, resolvedThemeCssFilename) {
    if (isVerbose) console.log(`Generating site for "${pageTitle}" in directory: ${outputDir}`);
    try { await fs.mkdir(outputDir, { recursive: true }); }
    catch (error) { throw new Error(`Failed to create output directory '${outputDir}': ${error.message}`); }

    const htmlContent = marked.parse(readmeContent);
    let faviconPathInHtml = '';
    let defaultOgImageForMeta = '';
    try {
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        const sourceDefaultImagePath = path.join(__dirname, 'assets', DEFAULT_IMAGE_FILENAME);
        await fs.access(sourceDefaultImagePath);
        const destDefaultImagePath = path.join(outputDir, DEFAULT_IMAGE_FILENAME);
        await fs.copyFile(sourceDefaultImagePath, destDefaultImagePath);
        faviconPathInHtml = DEFAULT_IMAGE_FILENAME;
        defaultOgImageForMeta = DEFAULT_IMAGE_FILENAME;
        if (isVerbose) console.log(`Using default image for favicon: ${DEFAULT_IMAGE_FILENAME}`);
    } catch (e) { console.warn(`Warning: Could not copy or access default image '${DEFAULT_IMAGE_FILENAME}'. Favicon may be missing. Error: ${e.message}`); }

    let finalOgImageUrl = ogImageUrlCli || defaultOgImageForMeta;
    if (ogImageUrlCli && isVerbose) console.log(`Using custom image for OG/Twitter previews: ${ogImageUrlCli}`);
    else if (!ogImageUrlCli && defaultOgImageForMeta && isVerbose) console.log(`Using default image as fallback OG image: ${defaultOgImageForMeta}`);

    let gaScriptHtml = '';
    if (gaPropertyId) {
        gaScriptHtml = `
    <script async src="https://www.googletagmanager.com/gtag/js?id=${gaPropertyId}"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', '${gaPropertyId}');
    </script>`;
        if (isVerbose) console.log(`Including Google Analytics script for ID: ${gaPropertyId}`);
    }

    let displayPathForConsoleAndFooter = "N/A";
    let repoUrlForConsoleAndFooter = footerLinkHref || ogUrlToUse || "";

    if (repoUrlForConsoleAndFooter) {
        try {
            const urlObj = new URL(repoUrlForConsoleAndFooter);
            let pathName = urlObj.pathname.endsWith('.git') ? urlObj.pathname.slice(0, -4) : urlObj.pathname;
            pathName = pathName.startsWith('/') ? pathName.substring(1) : pathName;
            displayPathForConsoleAndFooter = `${urlObj.hostname}/${pathName}`;
        } catch (e) {
            displayPathForConsoleAndFooter = repoUrlForConsoleAndFooter;
        }
    } else if (footerLinkText) {
        displayPathForConsoleAndFooter = footerLinkText;
        repoUrlForConsoleAndFooter = "Local file or unlinked source";
    } else {
        repoUrlForConsoleAndFooter = "Source repository not specified or detected.";
        displayPathForConsoleAndFooter = "N/A";
    }

    const safeConsoleRepoPath = displayPathForConsoleAndFooter
        .replace(/\\/g, '\\\\')
        .replace(/`/g, '\\`')
        .replace(/\$\{/g, '\\${}');

    const browserConsoleLogScript = `<script>
  console.log(\`
--------------------------------------------
Page generated by READMEsite
https://readme.site/

From the README.md file of the repository:
${safeConsoleRepoPath}
--------------------------------------------
  \`);
</script>`;

    let footerRepoSourceHtmlForDisplay = '';
    if (footerLinkHref && footerLinkText) {
        footerRepoSourceHtmlForDisplay = ` from <a href="${footerLinkHref}" target="_blank" rel="noopener noreferrer">${footerLinkText}</a>`;
    } else if (footerLinkText) {
        footerRepoSourceHtmlForDisplay = ` from ${footerLinkText}`;
    }

    let finalHtmlTemplateToUse = customHtmlTemplate || HTML_TEMPLATE;
    const cssFileToWrite = resolvedThemeCssFilename || 'style.css';
    const finalCssContentToUse = customCssContent || CSS_STYLES;


    // Modify the HTML template to link to the correct CSS file name
    const linkRegex = /<link\s+[^>]*?rel="stylesheet"[^>]*?(?:id="readmesite-theme-stylesheet"|href="style\.css")[^>]*?>/i;
    if (finalHtmlTemplateToUse.match(linkRegex)) {
        finalHtmlTemplateToUse = finalHtmlTemplateToUse.replace(
            linkRegex,
            `<link rel="stylesheet" href="${cssFileToWrite}" id="readmesite-theme-stylesheet">`
        );
    } else {
        // If no specific link found (e.g. custom HTML without a designated link), prepend the new link to head.
        finalHtmlTemplateToUse = finalHtmlTemplateToUse.replace(
            /(<\/head>)/i,
            `    <link rel="stylesheet" href="${cssFileToWrite}" id="readmesite-theme-stylesheet">\n$1`
        );
        if (isVerbose) console.log(`Info: No designated theme stylesheet link found; prepended link for ${cssFileToWrite}.`);
    }


    const finalHtml = finalHtmlTemplateToUse
        .replace(/{{PAGE_TITLE}}/g, pageTitle)
        .replace('{{GOOGLE_ANALYTICS_SCRIPT}}', gaScriptHtml)
        .replace(/{{OG_URL}}/g, ogUrlToUse || '')
        .replace(/{{FAVICON_URL}}/g, faviconPathInHtml)
        .replace(/{{OG_IMAGE_URL}}/g, finalOgImageUrl)
        .replace('{{FOOTER_REPO_SOURCE_HTML}}', footerRepoSourceHtmlForDisplay)
        .replace('{{BROWSER_CONSOLE_LOG_SCRIPT}}', browserConsoleLogScript)
        .replace('{{CONTENT}}', htmlContent);

    try { await fs.writeFile(path.join(outputDir, 'index.html'), finalHtml); if (isVerbose) console.log(`Successfully wrote index.html`); }
    catch (error) { throw new Error(`Failed to write index.html: ${error.message}`); }

    try { await fs.writeFile(path.join(outputDir, cssFileToWrite), finalCssContentToUse); if (isVerbose) console.log(`Successfully wrote ${cssFileToWrite}`); }
    catch (error) { throw new Error(`Failed to write ${cssFileToWrite}: ${error.message}`); }
}

function isLikelyRepoIdentifier(arg) { return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://'); }
function isUrl(str) { return str.startsWith('http:') || str.startsWith('https://') || str.startsWith('file://');}


async function main() {
    let rawArgs = process.argv.slice(2);

    if (rawArgs.includes('--verbose')) {
        if (!process.env.VERBOSE_READMESITE) process.env.VERBOSE_READMESITE = 'true';
        rawArgs = rawArgs.filter(arg => arg !== '--verbose');
        if (isVerbose) console.log("Verbose mode enabled.");
    }

    let repoIdentifierArg = null;
    let outputDirArg = DEFAULT_OUTPUT_DIR;
    let imageUrlArg = null;
    let gaPropertyIdArg = null;
    let themeArg = null;
    let paletteArg = null;

    let localMode = false;
    const localReadmePath = 'README.md';
    const remainingArgs = [];

    for (let i = 0; i < rawArgs.length; i++) {
        const arg = rawArgs[i];
        if (arg === '--image') {
            if (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) { imageUrlArg = rawArgs[++i]; }
            else { console.warn("Warning: --image flag needs a URL. Ignoring."); }
        } else if (arg === '--ga') {
            if (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) { gaPropertyIdArg = rawArgs[++i]; }
            else { console.warn("Warning: --ga flag needs an ID. Ignoring."); }
        } else if (arg === '--theme') {
            if (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) { themeArg = rawArgs[++i]; }
            else { console.warn("Warning: --theme flag needs a name/URL. Ignoring."); }
        } else if (arg === '--palette') {
            if (i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--')) { paletteArg = rawArgs[++i]; }
            else { console.warn("Warning: --palette flag needs a name. Ignoring."); }
        }
        else {
            remainingArgs.push(arg);
        }
    }
    rawArgs = remainingArgs;

    if (rawArgs.length === 0) { localMode = true; }
    else if (rawArgs.length === 1) { if (isLikelyRepoIdentifier(rawArgs[0])) { repoIdentifierArg = rawArgs[0]; } else { localMode = true; outputDirArg = rawArgs[0]; } }
    else { repoIdentifierArg = rawArgs[0]; outputDirArg = rawArgs[1]; }

    if (!localMode && !repoIdentifierArg && !themeArg) {
        console.error("Error: Operation could not be determined. Please provide a repository identifier or run with no identifier for local mode.\n");
        console.log("Usage for remote repository:");
        console.log("  readmesite <repository_identifier> [output_directory] [options]\n");
        console.log("Usage for local README.md (in current directory):");
        console.log("  readmesite [output_directory] [options]\n");
        console.log("Applying a theme to local README.md:");
        console.log("  readmesite --theme <theme_name_or_url> [output_directory] [options]\n")
        console.log("If no arguments are given, it processes ./README.md into the current directory ('.').\n");
        console.log("Options:");
        console.log("  --image <image_url>      URL for social media preview image.");
        console.log("  --ga <GA_ID>             Google Analytics Property ID (e.g., G-XXXXXXXXXX).");
        console.log("  --theme <name_or_url>    Name or URL of a theme. Filename based resolution.");
        console.log("  --palette <palette_name> Optional palette (e.g., 'ocean' for 'themename-ocean.css').");
        console.log("  --verbose                Enable verbose logging.");
        process.exit(1);
    }

    try {
        const resolvedOutputDir = path.resolve(outputDirArg);
        let pageTitle;
        let readmeContent;
        let ogUrlToUse = '';
        let footerLinkHref = null;
        let footerLinkText = null;

        let customCssContent = null;
        let customHtmlTemplate = null;
        let resolvedThemeCssFilename = null;

        if (themeArg) {
            let themeNameForFileResolution = themeArg; // This is the "base" themename
            let themeIsDirectUrl = isUrl(themeArg); // Is the themeArg itself a URL?

            if (themeIsDirectUrl && themeArg.endsWith('.css')) { // Full URL to a specific CSS file
                if (paletteArg) {
                    console.warn(`Warning: --palette '${paletteArg}' ignored because --theme is a direct URL to a CSS file: ${themeArg}`);
                    paletteArg = null; // Ignore palette if CSS file is directly specified
                }
                themeNameForFileResolution = path.basename(themeArg, '.css');
                // No separate baseThemeName needed, cssUrlOrPath will be themeArg
            } else if (paletteArg) {
                themeNameForFileResolution = `${themeArg}-${paletteArg}`;
            }
            // At this point, themeNameForFileResolution is like 'darkmode' or 'darkmode-ocean' OR a full URL if themeArg was a URL ending in .css

            let cssUrlOrPath, htmlUrlOrPath;

            if (themeIsDirectUrl) {
                if (themeArg.endsWith('.css')) { // Direct URL to CSS file
                    cssUrlOrPath = themeArg;
                    htmlUrlOrPath = themeArg.replace(/\.css$/, '.html');
                    resolvedThemeCssFilename = path.basename(cssUrlOrPath);
                } else { // URL is a "base" for the theme, e.g. https://store.readme.site/darkmode
                    // Construct filenames relative to this base URL
                    let baseThemeUrl = themeArg.endsWith('/') ? themeArg : themeArg + '/';
                    // The "theme name" part for the filename is the last part of the URL path
                    let themeFileStem = new URL(themeArg).pathname.split('/').filter(Boolean).pop() || themeArg;
                    if (paletteArg) {
                        themeFileStem = `${themeFileStem}-${paletteArg}`;
                    }
                    cssUrlOrPath = `${baseThemeUrl}${themeFileStem}.css`; // Incorrect, this appends if themeArg was https://.../darkmode
                                                                      // Should be new URL(themeFileStem + ".css", baseThemeUrl).toString() if baseThemeUrl is a dir
                    // Corrected URL construction for URL base:
                    const themeDirUrl = new URL(themeArg.endsWith('/') ? themeArg : themeArg + "/");
                    let themeNamePart = themeDirUrl.pathname.split('/').filter(Boolean).pop(); // e.g., 'darkmode' if URL is .../darkmode/
                    
                    let fileStemForUrl = themeNamePart;
                    if (paletteArg) {
                        fileStemForUrl = `${themeNamePart}-${paletteArg}`;
                    }

                    cssUrlOrPath = new URL(fileStemForUrl + ".css", themeDirUrl.href).toString();
                    htmlUrlOrPath = new URL(fileStemForUrl + ".html", themeDirUrl.href).toString();
                    resolvedThemeCssFilename = `${fileStemForUrl}.css`;
                }
            } else { // themeArg is a name like 'darkmode', not a URL
                let fileStemForLookup = themeArg;
                if (paletteArg) {
                    fileStemForLookup = `${themeArg}-${paletteArg}`;
                }
                resolvedThemeCssFilename = `${fileStemForLookup}.css`;

                // Try theme store
                cssUrlOrPath = `${THEME_STORE_BASE_URL}/${resolvedThemeCssFilename}`;
                htmlUrlOrPath = `${THEME_STORE_BASE_URL}/${fileStemForLookup}.html`;
                if (isVerbose) console.log(`Attempting to fetch from theme store: CSS='${cssUrlOrPath}', HTML='${htmlUrlOrPath}'`);

                customCssContent = await fetchOrReadContent(cssUrlOrPath, true);
                customHtmlTemplate = await fetchOrReadContent(htmlUrlOrPath, true);

                if (!customCssContent) { // Fallback to local if not found on store
                    cssUrlOrPath = path.join(LOCAL_THEMES_DIR, resolvedThemeCssFilename);
                    htmlUrlOrPath = path.join(LOCAL_THEMES_DIR, `${fileStemForLookup}.html`);
                    if (isVerbose) console.log(`Theme CSS not on store, trying local: CSS='${cssUrlOrPath}', HTML='${htmlUrlOrPath}'`);
                    // Fetch again from local below
                } else if (isVerbose && !customHtmlTemplate) {
                     if (isVerbose) console.log(`Theme HTML not on store, trying local: ${path.join(LOCAL_THEMES_DIR, `${fileStemForLookup}.html`)}`);
                     htmlUrlOrPath = path.join(LOCAL_THEMES_DIR, `${fileStemForLookup}.html`);
                     // HTML will be fetched below if customHtmlTemplate is still null
                }
            }
            
            if (isVerbose) console.log(`Resolved theme name for files: '${path.basename(resolvedThemeCssFilename, '.css')}'`);
            if (!customCssContent) { // Fetch if not already fetched (e.g. store failed, try local; or URL case)
                if (isVerbose) console.log(`Workspaceing CSS from: ${cssUrlOrPath}`);
                customCssContent = await fetchOrReadContent(cssUrlOrPath, true);
            }

            if (!customCssContent) {
                throw new Error(`Theme error: CSS file for theme '${path.basename(resolvedThemeCssFilename, '.css')}' not found at expected location(s).`);
            }

            if (!customHtmlTemplate) { // Fetch if not already fetched
                 if (isVerbose) console.log(`Workspaceing HTML from: ${htmlUrlOrPath}`);
                customHtmlTemplate = await fetchOrReadContent(htmlUrlOrPath, true);
            }

            if (customHtmlTemplate && isVerbose) {
                console.log(`Using custom HTML template for theme '${path.basename(resolvedThemeCssFilename, '.css')}'.`);
            } else if (isVerbose) {
                console.log(`No custom HTML template found for theme '${path.basename(resolvedThemeCssFilename, '.css')}', using default HTML structure.`);
            }
        }


        if (localMode && !readmeContent) { // If localMode is true and readmeContent hasn't been loaded (e.g. not set by theme-only mode)
             console.log(`Processing local '${localReadmePath}' -> '${resolvedOutputDir}'`);
             try { readmeContent = await fs.readFile(localReadmePath, 'utf-8'); }
             catch (readError) { if (readError.code === 'ENOENT') { throw new Error(`Local mode error: '${localReadmePath}' not found in the current directory.`); } throw new Error(`Local mode error: Could not read '${localReadmePath}': ${readError.message}`); }
            
            pageTitle = extractFirstH1(readmeContent);
            if (!pageTitle) { try { const pkgJsonPath = path.join(process.cwd(), 'package.json'); const pkgJsonContent = await fs.readFile(pkgJsonPath, 'utf-8'); const pkgJson = JSON.parse(pkgJsonContent); if (pkgJson && pkgJson.name) pageTitle = pkgJson.name; } catch (e) { /* ignore */ } }
            if (!pageTitle) pageTitle = path.basename(process.cwd());
            if (isVerbose) console.log(`Determined page title (local): "${pageTitle}"`);

            const localGitInfo = await getLocalGitRepoInfo();
            if (localGitInfo) {
                const sanitizedUrl = sanitizeUrlForPublicDisplay(localGitInfo.url);
                ogUrlToUse = ogUrlToUse || sanitizedUrl;
                footerLinkHref = footerLinkHref || sanitizedUrl;
                try {
                    const parsedUrl = new URL(sanitizedUrl); 
                    let pathName = parsedUrl.pathname.endsWith('.git') ? parsedUrl.pathname.slice(0, -4) : parsedUrl.pathname;
                    pathName = pathName.startsWith('/') ? pathName.substring(1) : pathName;
                    footerLinkText = footerLinkText || `${parsedUrl.hostname}/${pathName}`; 
                } catch(e) {footerLinkText = footerLinkText || localGitInfo.name; } 
                if (isVerbose) console.log(`Inferred source repository for footer/OG URL: ${footerLinkHref}`);
            }
        } else if (!localMode && repoIdentifierArg && !readmeContent) { // Remote mode, ensure readmeContent is loaded
            const initialRepoInfo = await parseRepoIdentifier(repoIdentifierArg);
            // ... (rest of remote mode logic to set readmeContent, pageTitle, ogUrlToUse, footerLinkHref, footerLinkText as before)
            let potentialOgUrl = '';
            if (initialRepoInfo.originalIdentifier && (initialRepoInfo.originalIdentifier.startsWith('https://') || initialRepoInfo.originalIdentifier.startsWith('http://'))) {
                 try { new URL(initialRepoInfo.originalIdentifier); potentialOgUrl = initialRepoInfo.originalIdentifier; } catch(e) {/*ignore*/}
            }
            ogUrlToUse = sanitizeUrlForPublicDisplay(potentialOgUrl);
            
            let logIdentifier = initialRepoInfo.originalIdentifier;
            if (initialRepoInfo.type === 'user_slash_repo') { logIdentifier = `${initialRepoInfo.user}/${initialRepoInfo.repoName}`; }
            console.log(`Processing remote repository '${logIdentifier}' -> '${resolvedOutputDir}'`);
            
            const fetchResult = await fetchReadmeContent(initialRepoInfo);
            readmeContent = fetchResult.readmeContent;
            const actualSourceRepoInfo = fetchResult.actualSourceRepoInfo;

            if (isVerbose) console.log(`README.md fetched successfully from ${actualSourceRepoInfo.host || 'resolved provider'}.`);

            pageTitle = extractFirstH1(readmeContent) || actualSourceRepoInfo.repoName;
            if (isVerbose) console.log(`Determined page title (remote): "${pageTitle}"`);
            
            let rawLinkUrl = ''; 
            if (actualSourceRepoInfo.type === 'github') { 
                rawLinkUrl = `https://github.com/${actualSourceRepoInfo.user}/${actualSourceRepoInfo.repoName}`; 
                footerLinkText = `github.com/${actualSourceRepoInfo.user}/${actualSourceRepoInfo.repoName}`; 
            } else if (actualSourceRepoInfo.type === 'gitlab') { 
                rawLinkUrl = `https://gitlab.com/${actualSourceRepoInfo.userOrGroupPath}/${actualSourceRepoInfo.repoName}`; 
                footerLinkText = `gitlab.com/${actualSourceRepoInfo.userOrGroupPath}/${actualSourceRepoInfo.repoName}`; 
            } else if (actualSourceRepoInfo.type === 'unknown_gitlab_like') { 
                rawLinkUrl = `https://${actualSourceRepoInfo.host}/${actualSourceRepoInfo.userOrGroupPath}/${actualSourceRepoInfo.repoName}`; 
                footerLinkText = `${actualSourceRepoInfo.host}/${actualSourceRepoInfo.userOrGroupPath}/${actualSourceRepoInfo.repoName}`; 
            }
            
            footerLinkHref = sanitizeUrlForPublicDisplay(rawLinkUrl); 
            
            if (!ogUrlToUse && footerLinkHref) {
                 ogUrlToUse = footerLinkHref; 
            } else if (!ogUrlToUse && rawLinkUrl) { 
                ogUrlToUse = sanitizeUrlForPublicDisplay(rawLinkUrl);
            }

            if (!footerLinkText && actualSourceRepoInfo.originalIdentifier) { 
                const sanitizedOriginalId = sanitizeUrlForPublicDisplay(actualSourceRepoInfo.originalIdentifier);
                try {
                    const parsedId = new URL(sanitizedOriginalId);
                     let pathName = parsedId.pathname.endsWith('.git') ? parsedId.pathname.slice(0, -4) : parsedId.pathname;
                    pathName = pathName.startsWith('/') ? pathName.substring(1) : pathName;
                    footerLinkText = `${parsedId.hostname}/${pathName}`;
                } catch(e) { footerLinkText = sanitizedOriginalId; }
            }
        }
        
        if (!readmeContent) {
            throw new Error("Could not load README content for processing.");
        }
        if (!pageTitle) { // Final fallback for page title
            pageTitle = "READMEsite";
        }
        
        await generateSite(readmeContent, pageTitle, resolvedOutputDir, ogUrlToUse, imageUrlArg, 
                            footerLinkHref, footerLinkText, gaPropertyIdArg, 
                            customCssContent, customHtmlTemplate, resolvedThemeCssFilename);

        console.log(`\n✅ Site generation complete!`);
        console.log(`Static site files are located in: ${resolvedOutputDir}`);

        if (!process.env.CI) {
            // ... (deployment hints) ...
        }
    } catch (error) {
        console.error(`\n❌ Error: ${error.message}`);
        if (error.cause && isVerbose) { console.error(`Cause: ${error.cause}`); }
        if (isVerbose && error.stack) console.error(error.stack);
        process.exit(1);
    }
}

main();
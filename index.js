#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import { fileURLToPath } from 'url';

const DEFAULT_OUTPUT_DIR = 'public';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_FILENAME = 'readmesite-og-default.png'; 

const HTML_TEMPLATE = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>{{PAGE_TITLE}}</title><meta property="og:type" content="website"><meta property="og:url" content="{{OG_URL}}"><meta property="og:title" content="{{PAGE_TITLE}}"><meta property="og:description" content="View the README for the {{PAGE_TITLE}} repository."><meta property="og:image" content="{{OG_IMAGE_URL}}"><meta property="og:site_name" content="{{PAGE_TITLE}}"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:url" content="{{OG_URL}}"><meta name="twitter:title" content="{{PAGE_TITLE}}"><meta name="twitter:description" content="View the README for the {{PAGE_TITLE}} repository."><meta name="twitter:image" content="{{OG_IMAGE_URL}}"><link rel="stylesheet" href="style.css"><link rel="icon" href="{{FAVICON_URL}}" type="image/png"></head><body><main class="container">{{CONTENT}}</main><footer><p>Generated by <a href="https://readme.site" target="_blank" rel="noopener noreferrer">READMEsite</a></p></footer></body></html>`;
const CSS_STYLES = `body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;} .container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);} h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;} h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;} p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;} a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;} code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;} pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;} pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;} img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;} blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;} table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;} th,td {border:1px solid #dfe2e5; padding:6px 13px;} tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;} hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;} footer {text-align:center; margin-top:40px; padding-top:20px; border-top:1px solid #eaecef; font-size:.9em; color:#586069;} footer a {color:#0366d6;}`;

async function parseRepoIdentifier(identifier) { if (!identifier) { throw new Error("Repository identifier argument is missing."); } try { const url = new URL(identifier); const hostname = url.hostname.toLowerCase(); const pathParts = url.pathname.split('/').filter(Boolean); if (pathParts.length < 2) { throw new Error(`URL path does not seem to contain enough segments for a repository: ${url.pathname}`); } if (hostname === 'github.com') { return { type: 'github', host: hostname, user: pathParts[0], repoName: pathParts[1], originalIdentifier: identifier }; } else if (hostname === 'gitlab.com') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); return { type: 'gitlab', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } else if (url.protocol === 'https:') { const repoName = pathParts[pathParts.length - 1]; const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/'); console.warn(`Processing unknown host '${hostname}' using GitLab-like URL pattern for raw files.`); return { type: 'unknown_gitlab_like', host: hostname, userOrGroupPath: userOrGroupPath, repoName: repoName, originalIdentifier: identifier }; } } catch (e) { if (!(e instanceof TypeError && e.message.includes("Invalid URL"))) { console.warn(`URL parsing attempt failed for '${identifier}': ${e.message}. Will try as 'user/repo'.`); } } if (identifier.includes('://')) { throw new Error(`Invalid repository identifier: '${identifier}'. Full URLs must be valid. For 'user/repo' shorthand, do not include protocol.`); } const parts = identifier.split('/'); if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) { return { type: 'user_slash_repo', user: parts[0], repoName: parts[1], originalIdentifier: identifier }; } throw new Error(`Could not parse repository identifier: '${identifier}'. Please use 'username/repository' format or a full HTTPS URL.`); }
async function tryFetchForProvider(providerRepoInfo, branches, filePath) { let lastBranchError = null; for (const branch of branches) { let readmeUrl; const repoDisplayPath = providerRepoInfo.type === 'github' ? `${providerRepoInfo.user}/${providerRepoInfo.repoName}` : `${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`; if (providerRepoInfo.type === 'github') { readmeUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`; } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') { readmeUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`; } else { return { content: null, error: new Error(`Internal error: Unsupported provider type: ${providerRepoInfo.type}`) }; } if (process.env.VERBOSE_READMESITE) console.log(`Attempting: ${readmeUrl}`); try { const response = await fetch(readmeUrl); if (response.ok) { return { content: await response.text(), error: null }; } if (response.status === 404) { lastBranchError = new Error(`${filePath} not found on branch '${branch}' for ${repoDisplayPath} at ${providerRepoInfo.host}`); if (process.env.VERBOSE_READMESITE) console.warn(lastBranchError.message); } else { throw new Error(`Failed to fetch ${filePath} from ${readmeUrl}. Status: ${response.status} ${response.statusText}`); } } catch (fetchError) { lastBranchError = new Error(`Network/fetch error for ${readmeUrl}: ${fetchError.message}`); console.warn(lastBranchError.message); return { content: null, error: lastBranchError }; } } return { content: null, error: lastBranchError || new Error(`${filePath} not found on any attempted branch for ${repoDisplayPath} at ${providerRepoInfo.host}.`) }; }
async function fetchReadmeContent(repoInfo) { const filePath = 'README.md'; if (repoInfo.type === 'user_slash_repo') { if (process.env.VERBOSE_READMESITE) console.log(`Input '${repoInfo.originalIdentifier}' is 'username/repository' shorthand.`); if (process.env.VERBOSE_READMESITE) console.log("Attempting to resolve on GitHub (github.com)..."); const githubInfo = { type: 'github', host: 'github.com', user: repoInfo.user, repoName: repoInfo.repoName, originalIdentifier: repoInfo.originalIdentifier }; let result = await tryFetchForProvider(githubInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; console.warn(`GitHub attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); if (process.env.VERBOSE_READMESITE) console.log("Attempting to resolve on GitLab (gitlab.com)..."); const gitlabInfo = { type: 'gitlab', host: 'gitlab.com', userOrGroupPath: repoInfo.user, repoName: repoInfo.repoName, originalIdentifier: repoInfo.originalIdentifier }; result = await tryFetchForProvider(gitlabInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; console.warn(`GitLab.com attempt for '${repoInfo.originalIdentifier}' failed or README not found: ${result.error ? result.error.message : "README not found"}`); throw new Error(`Could not resolve '${repoInfo.originalIdentifier}' on GitHub or GitLab.com, or ${filePath} not found on any tried branch.`); } else { const result = await tryFetchForProvider(repoInfo, CHECK_BRANCHES_ORDER, filePath); if (result.content) return result.content; throw result.error || new Error(`Could not find ${filePath} for '${repoInfo.originalIdentifier}' on any of the branches: ${CHECK_BRANCHES_ORDER.join(', ')}.`); } }

async function generateSite(readmeContent, pageTitleBase, outputDir, repoOriginalIdentifier, ogImageUrlCli) {
    const isVerbose = process.env.VERBOSE_READMESITE === 'true'; // Check for verbose environment variable

    if (isVerbose) console.log(`Generating site in directory: ${outputDir}`);
    try {
        await fs.mkdir(outputDir, { recursive: true });
    } catch (error) {
        throw new Error(`Failed to create output directory '${outputDir}': ${error.message}`);
    }

    const htmlContent = marked.parse(readmeContent);
    const sitePageTitle = pageTitleBase;

    let ogUrlValue = '';
    if (repoOriginalIdentifier && (repoOriginalIdentifier.startsWith('https://') || repoOriginalIdentifier.startsWith('http://'))) {
        try {
            new URL(repoOriginalIdentifier);
            ogUrlValue = repoOriginalIdentifier;
        } catch (e) {
            console.warn(`Original identifier '${repoOriginalIdentifier}' is not a valid URL for og:url. Omitting.`);
        }
    }

    let faviconPathInHtml = '';
    let ogImageMetaTagUrl = '';

    try {
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        const sourceDefaultImagePath = path.join(__dirname, 'assets', DEFAULT_IMAGE_FILENAME);
        
        await fs.access(sourceDefaultImagePath);
        const destDefaultImagePath = path.join(outputDir, DEFAULT_IMAGE_FILENAME);
        await fs.copyFile(sourceDefaultImagePath, destDefaultImagePath);
        
        faviconPathInHtml = DEFAULT_IMAGE_FILENAME;
        ogImageMetaTagUrl = DEFAULT_IMAGE_FILENAME;
        if (isVerbose) console.log(`Using default image for favicon and as fallback OG image: ${DEFAULT_IMAGE_FILENAME}`);
    } catch (e) {
        console.warn(`Warning: Could not copy or access default image '${DEFAULT_IMAGE_FILENAME}'. Favicon and default OG image may be missing. Error: ${e.message}`);
    }

    if (ogImageUrlCli) {
        ogImageMetaTagUrl = ogImageUrlCli;
        if (isVerbose) console.log(`Using custom image for OG/Twitter previews: ${ogImageUrlCli}`);
    }

    const finalHtml = HTML_TEMPLATE
        .replace(/{{PAGE_TITLE}}/g, sitePageTitle)
        .replace(/{{OG_URL}}/g, ogUrlValue)
        .replace(/{{FAVICON_URL}}/g, faviconPathInHtml)
        .replace(/{{OG_IMAGE_URL}}/g, ogImageMetaTagUrl)
        .replace('{{CONTENT}}', htmlContent);

    try {
        await fs.writeFile(path.join(outputDir, 'index.html'), finalHtml);
        if (isVerbose) console.log(`Successfully wrote index.html`);
    } catch (error) {
        throw new Error(`Failed to write index.html: ${error.message}`);
    }

    try {
        await fs.writeFile(path.join(outputDir, 'style.css'), CSS_STYLES);
        if (isVerbose) console.log(`Successfully wrote style.css`);
    } catch (error) {
        throw new Error(`Failed to write style.css: ${error.message}`);
    }
}

function isLikelyRepoIdentifier(arg) {
    return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://');
}

async function main() {
    const rawArgs = process.argv.slice(2);
    let repoIdentifierArg = null;
    let outputDirArg = DEFAULT_OUTPUT_DIR;
    let imageUrlArg = null;
    let localMode = false;
    const localReadmePath = 'README.md';
    // Simple verbosity check: if --verbose is present anywhere.
    const verboseIndex = rawArgs.indexOf('--verbose');
    const isVerbose = verboseIndex !== -1;
    if (isVerbose) {
        process.env.VERBOSE_READMESITE = 'true'; // Set an env var for other functions to see
        rawArgs.splice(verboseIndex, 1); // Remove --verbose from args
    }


    const imageFlagIndex = rawArgs.indexOf('--image');
    if (imageFlagIndex !== -1) { /* ... (image arg parsing as before) ... */ if (imageFlagIndex + 1 < rawArgs.length && !rawArgs[imageFlagIndex + 1].startsWith('--')) { imageUrlArg = rawArgs[imageFlagIndex + 1]; rawArgs.splice(imageFlagIndex, 2); } else { console.warn("Warning: --image flag provided without a valid URL. Ignoring flag."); rawArgs.splice(imageFlagIndex, 1); } }

    if (rawArgs.length === 0) {
        localMode = true;
    } else if (rawArgs.length === 1) {
        if (isLikelyRepoIdentifier(rawArgs[0])) {
            repoIdentifierArg = rawArgs[0];
        } else {
            localMode = true;
            outputDirArg = rawArgs[0];
        }
    } else {
        repoIdentifierArg = rawArgs[0];
        outputDirArg = rawArgs[1];
    }

    if (!localMode && !repoIdentifierArg) {
        console.error("Error: Repository identifier is required for remote mode, or run with no identifier for local mode.\n");
        // ... (Full usage message as before, including --verbose option) ...
        console.log("Usage for remote repository:");
        console.log("  readmesite <repository_identifier> [output_directory] [--image <image_url>] [--verbose]\n");
        console.log("Usage for local README.md (in current directory):");
        console.log("  readmesite [output_directory] [--image <image_url>] [--verbose]\n");
        console.log("If no arguments are given, it processes ./README.md into ./public.\n");
        console.log("Options:");
        console.log("  --image <image_url>      URL for social media preview image.");
        console.log("  --verbose                Enable verbose logging.");
        process.exit(1);
    }

    try {
        const resolvedOutputDir = path.resolve(outputDirArg);
        if (localMode) {
            console.log(`Processing local '${localReadmePath}' -> '${resolvedOutputDir}'`);
             if (isVerbose && imageUrlArg) console.log(`Custom image for social previews: ${imageUrlArg}`);

            let readmeContent;
            try {
                readmeContent = await fs.readFile(localReadmePath, 'utf-8');
            } catch (readError) { /* ... error handling ... */ if (readError.code === 'ENOENT') { throw new Error(`Local mode error: '${localReadmePath}' not found in the current directory.`); } throw new Error(`Local mode error: Could not read '${localReadmePath}': ${readError.message}`); }
            
            const pageTitle = path.basename(process.cwd());
            await generateSite(readmeContent, pageTitle, resolvedOutputDir, null, imageUrlArg);

        } else { // Remote mode
            const repoInfo = await parseRepoIdentifier(repoIdentifierArg);
            let logIdentifier = repoInfo.originalIdentifier;
            if (repoInfo.type === 'user_slash_repo') {
                 logIdentifier = `${repoInfo.user}/${repoInfo.repoName}`;
            }
            console.log(`Processing remote repository '${logIdentifier}' -> '${resolvedOutputDir}'`);
             if (isVerbose && imageUrlArg) console.log(`Custom image for social previews: ${imageUrlArg}`);
            
            const readmeContent = await fetchReadmeContent(repoInfo);
            if (isVerbose) console.log("README.md fetched successfully.");

            await generateSite(readmeContent, repoInfo.repoName, resolvedOutputDir, repoInfo.originalIdentifier, imageUrlArg);
        }

        console.log(`\n✅ Site generation complete!`);
        console.log(`Static site files are located in: ${resolvedOutputDir}`);


    } catch (error) { /* ... error handling ... */ console.error(`\n❌ Error: ${error.message}`); if (error.cause) { console.error(`Cause: ${error.cause}`); } process.exit(1); }
}

main();